<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Effective Go</title>
      <link href="/effective_go/"/>
      <url>/effective_go/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Go is a new language.  Although it borrows ideas from<br>existing languages,<br>it has unusual properties that make effective Go programs<br>different in character from programs written in its relatives.<br>A straightforward translation of a C++ or Java program into Go<br>is unlikely to produce a satisfactory result&mdash;Java programs<br>are written in Java, not Go.<br>On the other hand, thinking about the problem from a Go<br>perspective could produce a successful but quite different<br>program.<br>In other words,<br>to write Go well, it’s important to understand its properties<br>and idioms.<br>It’s also important to know the established conventions for<br>programming in Go, such as naming, formatting, program<br>construction, and so on, so that programs you write<br>will be easy for other Go programmers to understand.</p><p>This document gives tips for writing clear, idiomatic Go code.It augments the <a href="/ref/spec">language specification</a>,the <a href="//tour.golang.org/">Tour of Go</a>,and <a href="/doc/code.html">How to Write Go Code</a>,all of which youshould read first.</p><h3 id="examples">Examples</h3><p>The <a href="/src/">Go package sources</a>are intended to serve notonly as the core library but also as examples of how touse the language.Moreover, many of the packages contain working, self-containedexecutable examples you can run directly from the<a href="//golang.org">golang.org</a> web site, such as<a href="//golang.org/pkg/strings/#example_Map">this one</a> (ifnecessary, click on the word "Example" to open it up).If you have a question about how to approach a problem or how somethingmight be implemented, the documentation, code and examples in thelibrary can provide answers, ideas andbackground.</p><h2 id="formatting">Formatting</h2><p>Formatting issues are the most contentiousbut the least consequential.People can adapt to different formatting stylesbut it's better if they don't have to, andless time is devoted to the topicif everyone adheres to the same style.The problem is how to approach this Utopia without a longprescriptive style guide.</p><p>With Go we take an unusualapproach and let the machinetake care of most formatting issues.The <code>gofmt</code> program(also available as <code>go fmt</code>, whichoperates at the package level rather than source file level)reads a Go programand emits the source in a standard style of indentationand vertical alignment, retaining and if necessaryreformatting comments.If you want to know how to handle some new layoutsituation, run <code>gofmt</code>; if the answer doesn'tseem right, rearrange your program (or file a bug about <code>gofmt</code>),don't work around it.</p><p>As an example, there's no need to spend time lining upthe comments on the fields of a structure.<code>Gofmt</code> will do that for you.  Given thedeclaration</p><pre>type T struct {    name string // name of the object    value int // its value}</pre><p><code>gofmt</code> will line up the columns:</p><pre>type T struct {    name    string // name of the object    value   int    // its value}</pre><p>All Go code in the standard packages has been formatted with <code>gofmt</code>.</p><p>Some formatting details remain.  Very briefly:</p><dl>    <dt>Indentation</dt>    <dd>We use tabs for indentation and <code>gofmt</code> emits them by default.    Use spaces only if you must.    </dd>    <dt>Line length</dt>    <dd>    Go has no line length limit.  Don't worry about overflowing a punched card.    If a line feels too long, wrap it and indent with an extra tab.    </dd>    <dt>Parentheses</dt>    <dd>    Go needs fewer parentheses than C and Java: control structures (<code>if</code>,    <code>for</code>, <code>switch</code>) do not have parentheses in    their syntax.    Also, the operator precedence hierarchy is shorter and clearer, so<pre>x&lt;&lt;8 + y&lt;&lt;16</pre>    means what the spacing implies, unlike in the other languages.    </dd></dl><h2 id="commentary">Commentary</h2><p>Go provides C-style <code>/* */</code> block commentsand C++-style <code>//</code> line comments.Line comments are the norm;block comments appear mostly as package comments, butare useful within an expression or to disable large swaths of code.</p><p>The program—and web server—<code>godoc</code> processesGo source files to extract documentation about the contents of thepackage.Comments that appear before top-level declarations, with no intervening newlines,are extracted along with the declaration to serve as explanatory text for the item.The nature and style of these comments determines thequality of the documentation <code>godoc</code> produces.</p><p>Every package should have a <i>package comment</i>, a blockcomment preceding the package clause.For multi-file packages, the package comment only needs to bepresent in one file, and any one will do.The package comment should introduce the package andprovide information relevant to the package as a whole.It will appear first on the <code>godoc</code> page andshould set up the detailed documentation that follows.</p><pre>/*Package regexp implements a simple library for regular expressions.The syntax of the regular expressions accepted is:    regexp:        concatenation { '|' concatenation }    concatenation:        { closure }    closure:        term [ '*' | '+' | '?' ]    term:        '^'        '$'        '.'        character        '[' [ '^' ] character-ranges ']'        '(' regexp ')'*/package regexp</pre><p>If the package is simple, the package comment can be brief.</p><pre>// Package path implements utility routines for// manipulating slash-separated filename paths.</pre><p>Comments do not need extra formatting such as banners of stars.The generated output may not even be presented in a fixed-width font, so don't dependon spacing for alignment&mdash;<code>godoc</code>, like <code>gofmt</code>,takes care of that.The comments are uninterpreted plain text, so HTML and otherannotations such as <code>_this_</code> will reproduce <i>verbatim</i> and shouldnot be used.One adjustment <code>godoc</code> does do is to display indentedtext in a fixed-width font, suitable for program snippets.The package comment for the<a href="/pkg/fmt/"><code>fmt</code> package</a> uses this to good effect.</p><p>Depending on the context, <code>godoc</code> might not evenreformat comments, so make sure they look good straight up:use correct spelling, punctuation, and sentence structure,fold long lines, and so on.</p><p>Inside a package, any comment immediately preceding a top-level declarationserves as a <i>doc comment</i> for that declaration.Every exported (capitalized) name in a program shouldhave a doc comment.</p><p>Doc comments work best as complete sentences, which allowa wide variety of automated presentations.The first sentence should be a one-sentence summary thatstarts with the name being declared.</p><pre>// Compile parses a regular expression and returns, if successful,// a Regexp that can be used to match against text.func Compile(str string) (*Regexp, error) {</pre><p>If every doc comment begins with the name of the item it describes,you can use the <a href="/cmd/go/#hdr-Show_documentation_for_package_or_symbol">doc</a>subcommand of the <a href="/cmd/go/">go</a> tooland run the output through <code>grep</code>.Imagine you couldn't remember the name "Compile" but were looking forthe parsing function for regular expressions, so you ranthe command,</p><pre>$ go doc -all regexp | grep -i parse</pre><p>If all the doc comments in the package began, "This function...", <code>grep</code>wouldn't help you remember the name. But because the package starts eachdoc comment with the name, you'd see something like this,which recalls the word you're looking for.</p><pre>$ go doc -all regexp | grep -i parse    Compile parses a regular expression and returns, if successful, a Regexp    MustCompile is like Compile but panics if the expression cannot be parsed.    parsed. It simplifies safe initialization of global variables holding$</pre><p>Go's declaration syntax allows grouping of declarations.A single doc comment can introduce a group of related constants or variables.Since the whole declaration is presented, such a comment can often be perfunctory.</p><pre>// Error codes returned by failures to parse an expression.var (    ErrInternal      = errors.New("regexp: internal error")    ErrUnmatchedLpar = errors.New("regexp: unmatched '('")    ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")    ...)</pre><p>Grouping can also indicate relationships between items,such as the fact that a set of variables is protected by a mutex.</p><pre>var (    countLock   sync.Mutex    inputCount  uint32    outputCount uint32    errorCount  uint32)</pre><h2 id="names">Names</h2><p>Names are as important in Go as in any other language.They even have semantic effect:the visibility of a name outside a package is determined by whether itsfirst character is upper case.It's therefore worth spending a little time talking about naming conventionsin Go programs.</p><h3 id="package-names">Package names</h3><p>When a package is imported, the package name becomes an accessor for thecontents.  After</p><pre>import "bytes"</pre><p>the importing package can talk about <code>bytes.Buffer</code>.  It'shelpful if everyone using the package can use the same name to refer toits contents, which implies that the package name should be good:short, concise, evocative.  By convention, packages are givenlower case, single-word names; there should be no need for underscoresor mixedCaps.Err on the side of brevity, since everyone using yourpackage will be typing that name.And don't worry about collisions <i>a priori</i>.The package name is only the default name for imports; it need not be uniqueacross all source code, and in the rare case of a collision theimporting package can choose a different name to use locally.In any case, confusion is rare because the file name in the importdetermines just which package is being used.</p><p>Another convention is that the package name is the base name ofits source directory;the package in <code>src/encoding/base64</code>is imported as <code>"encoding/base64"</code> but has name <code>base64</code>,not <code>encoding_base64</code> and not <code>encodingBase64</code>.</p><p>The importer of a package will use the name to refer to its contents,so exported names in the package can use that factto avoid stutter.(Don't use the <code>import .</code> notation, which can simplifytests that must run outside the package they are testing, but should otherwise be avoided.)For instance, the buffered reader type in the <code>bufio</code> package is called <code>Reader</code>,not <code>BufReader</code>, because users see it as <code>bufio.Reader</code>,which is a clear, concise name.Moreover,because imported entities are always addressed with their package name, <code>bufio.Reader</code>does not conflict with <code>io.Reader</code>.Similarly, the function to make new instances of <code>ring.Ring</code>&mdash;whichis the definition of a <em>constructor</em> in Go&mdash;wouldnormally be called <code>NewRing</code>, but since<code>Ring</code> is the only type exported by the package, and since thepackage is called <code>ring</code>, it's called just <code>New</code>,which clients of the package see as <code>ring.New</code>.Use the package structure to help you choose good names.</p><p>Another short example is <code>once.Do</code>;<code>once.Do(setup)</code> reads well and would not be improved bywriting <code>once.DoOrWaitUntilDone(setup)</code>.Long names don't automatically make things more readable.A helpful doc comment can often be more valuable than an extra long name.</p><h3 id="Getters">Getters</h3><p>Go doesn't provide automatic support for getters and setters.There's nothing wrong with providing getters and setters yourself,and it's often appropriate to do so, but it's neither idiomatic nor necessaryto put <code>Get</code> into the getter's name.  If you have a field called<code>owner</code> (lower case, unexported), the getter method should becalled <code>Owner</code> (upper case, exported), not <code>GetOwner</code>.The use of upper-case names for export provides the hook to discriminatethe field from the method.A setter function, if needed, will likely be called <code>SetOwner</code>.Both names read well in practice:</p><pre>owner := obj.Owner()if owner != user {    obj.SetOwner(user)}</pre><h3 id="interface-names">Interface names</h3><p>By convention, one-method interfaces are named bythe method name plus an -er suffix or similar modificationto construct an agent noun: <code>Reader</code>,<code>Writer</code>, <code>Formatter</code>,<code>CloseNotifier</code> etc.</p><p>There are a number of such names and it's productive to honor them and the functionnames they capture.<code>Read</code>, <code>Write</code>, <code>Close</code>, <code>Flush</code>,<code>String</code> and so on havecanonical signatures and meanings.  To avoid confusion,don't give your method one of those names unless ithas the same signature and meaning.Conversely, if your type implements a method with thesame meaning as a method on a well-known type,give it the same name and signature;call your string-converter method <code>String</code> not <code>ToString</code>.</p><h3 id="mixed-caps">MixedCaps</h3><p>Finally, the convention in Go is to use <code>MixedCaps</code>or <code>mixedCaps</code> rather than underscores to writemultiword names.</p><h2 id="semicolons">Semicolons</h2><p>Like C, Go's formal grammar uses semicolons to terminate statements,but unlike in C, those semicolons do not appear in the source.Instead the lexer uses a simple rule to insert semicolons automaticallyas it scans, so the input text is mostly free of them.</p><p>The rule is this. If the last token before a newline is an identifier(which includes words like <code>int</code> and <code>float64</code>),a basic literal such as a number or string constant, or one of thetokens</p><pre>break continue fallthrough return ++ -- ) }</pre><p>the lexer always inserts a semicolon after the token.This could be summarized as, &ldquo;if the newline comesafter a token that could end a statement, insert a semicolon&rdquo;.</p><p>A semicolon can also be omitted immediately before a closing brace,so a statement such as</p><pre>    go func() { for { dst &lt;- &lt;-src } }()</pre><p>needs no semicolons.Idiomatic Go programs have semicolons only in places such as<code>for</code> loop clauses, to separate the initializer, condition, andcontinuation elements.  They are also necessary to separate multiplestatements on a line, should you write code that way.</p><p>One consequence of the semicolon insertion rulesis that you cannot put the opening brace of acontrol structure (<code>if</code>, <code>for</code>, <code>switch</code>,or <code>select</code>) on the next line.  If you do, a semicolonwill be inserted before the brace, which could cause unwantedeffects.  Write them like this</p><pre>if i &lt; f() {    g()}</pre><p>not like this</p><pre>if i &lt; f()  // wrong!{           // wrong!    g()}</pre><h2 id="control-structures">Control structures</h2><p>The control structures of Go are related to those of C but differin important ways.There is no <code>do</code> or <code>while</code> loop, only aslightly generalized<code>for</code>;<code>switch</code> is more flexible;<code>if</code> and <code>switch</code> accept an optionalinitialization statement like that of <code>for</code>;<code>break</code> and <code>continue</code> statementstake an optional label to identify what to break or continue;and there are new control structures including a type switch and amultiway communications multiplexer, <code>select</code>.The syntax is also slightly different:there are no parenthesesand the bodies must always be brace-delimited.</p><h3 id="if">If</h3><p>In Go a simple <code>if</code> looks like this:</p><pre>if x &gt; 0 {    return y}</pre><p>Mandatory braces encourage writing simple <code>if</code> statementson multiple lines.  It's good style to do so anyway,especially when the body contains a control statement such as a<code>return</code> or <code>break</code>.</p><p>Since <code>if</code> and <code>switch</code> accept an initializationstatement, it's common to see one used to set up a local variable.</p><pre>if err := file.Chmod(0664); err != nil {    log.Print(err)    return err}</pre><p id="else">In the Go libraries, you'll find thatwhen an <code>if</code> statement doesn't flow into the next statement—that is,the body ends in <code>break</code>, <code>continue</code>,<code>goto</code>, or <code>return</code>—the unnecessary<code>else</code> is omitted.</p><pre>f, err := os.Open(name)if err != nil {    return err}codeUsing(f)</pre><p>This is an example of a common situation where code must guard against asequence of error conditions.  The code reads well if thesuccessful flow of control runs down the page, eliminating error casesas they arise.  Since error cases tend to end in <code>return</code>statements, the resulting code needs no <code>else</code> statements.</p><pre>f, err := os.Open(name)if err != nil {    return err}d, err := f.Stat()if err != nil {    f.Close()    return err}codeUsing(f, d)</pre><h3 id="redeclaration">Redeclaration and reassignment</h3><p>An aside: The last example in the previous section demonstrates a detail of how the<code>:=</code> short declaration form works.The declaration that calls <code>os.Open</code> reads,</p><pre>f, err := os.Open(name)</pre><p>This statement declares two variables, <code>f</code> and <code>err</code>.A few lines later, the call to <code>f.Stat</code> reads,</p><pre>d, err := f.Stat()</pre><p>which looks as if it declares <code>d</code> and <code>err</code>.Notice, though, that <code>err</code> appears in both statements.This duplication is legal: <code>err</code> is declared by the first statement,but only <em>re-assigned</em> in the second.This means that the call to <code>f.Stat</code> uses the existing<code>err</code> variable declared above, and just gives it a new value.</p><p>In a <code>:=</code> declaration a variable <code>v</code> may appear evenif it has already been declared, provided:</p><ul><li>this declaration is in the same scope as the existing declaration of <code>v</code>(if <code>v</code> is already declared in an outer scope, the declaration will create a new variable §),</li><li>the corresponding value in the initialization is assignable to <code>v</code>, and</li><li>there is at least one other variable in the declaration that is being declared anew.</li></ul><p>This unusual property is pure pragmatism,making it easy to use a single <code>err</code> value, for example,in a long <code>if-else</code> chain.You'll see it used often.</p><p>§ It's worth noting here that in Go the scope of function parameters and return valuesis the same as the function body, even though they appear lexically outside the bracesthat enclose the body.</p><h3 id="for">For</h3><p>The Go <code>for</code> loop is similar to&mdash;but not the same as&mdash;C's.It unifies <code>for</code>and <code>while</code> and there is no <code>do-while</code>.There are three forms, only one of which has semicolons.</p><pre>// Like a C forfor init; condition; post { }<p>// Like a C while<br>for condition { }</p><p>// Like a C for(;;)<br>for { }<br></p></pre><p></p><p>Short declarations make it easy to declare the index variable right in the loop.</p><pre>sum := 0for i := 0; i &lt; 10; i++ {    sum += i}</pre><p>If you're looping over an array, slice, string, or map,or reading from a channel, a <code>range</code> clause canmanage the loop.</p><pre>for key, value := range oldMap {    newMap[key] = value}</pre><p>If you only need the first item in the range (the key or index), drop the second:</p><pre>for key := range m {    if key.expired() {        delete(m, key)    }}</pre><p>If you only need the second item in the range (the value), use the <em>blank identifier</em>, an underscore, to discard the first:</p><pre>sum := 0for _, value := range array {    sum += value}</pre><p>The blank identifier has many uses, as described in <a href="#blank">a later section</a>.</p><p>For strings, the <code>range</code> does more work for you, breaking out individualUnicode code points by parsing the UTF-8.Erroneous encodings consume one byte and produce thereplacement rune U+FFFD.(The name (with associated builtin type) <code>rune</code> is Go terminology for asingle Unicode code point.See <a href="/ref/spec#Rune_literals">the language specification</a>for details.)The loop</p><pre>for pos, char := range "日本\x80語" { // \x80 is an illegal UTF-8 encoding    fmt.Printf("character %#U starts at byte position %d\n", char, pos)}</pre><p>prints</p><pre>character U+65E5 '日' starts at byte position 0character U+672C '本' starts at byte position 3character U+FFFD '�' starts at byte position 6character U+8A9E '語' starts at byte position 7</pre><p>Finally, Go has no comma operator and <code>++</code> and <code>--</code>are statements not expressions.Thus if you want to run multiple variables in a <code>for</code>you should use parallel assignment (although that precludes <code>++</code> and <code>--</code>).</p><pre>// Reverse afor i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 {    a[i], a[j] = a[j], a[i]}</pre><h3 id="switch">Switch</h3><p>Go's <code>switch</code> is more general than C's.The expressions need not be constants or even integers,the cases are evaluated top to bottom until a match is found,and if the <code>switch</code> has no expression it switches on<code>true</code>.It's therefore possible&mdash;and idiomatic&mdash;to write an<code>if</code>-<code>else</code>-<code>if</code>-<code>else</code>chain as a <code>switch</code>.</p><pre>func unhex(c byte) byte {    switch {    case '0' &lt;= c &amp;&amp; c &lt;= '9':        return c - '0'    case 'a' &lt;= c &amp;&amp; c &lt;= 'f':        return c - 'a' + 10    case 'A' &lt;= c &amp;&amp; c &lt;= 'F':        return c - 'A' + 10    }    return 0}</pre><p>There is no automatic fall through, but cases can be presentedin comma-separated lists.</p><pre>func shouldEscape(c byte) bool {    switch c {    case ' ', '?', '&amp;', '=', '#', '+', '%':        return true    }    return false}</pre><p>Although they are not nearly as common in Go as some other C-likelanguages, <code>break</code> statements can be used to terminatea <code>switch</code> early.Sometimes, though, it's necessary to break out of a surrounding loop,not the switch, and in Go that can be accomplished by putting a labelon the loop and "breaking" to that label.This example shows both uses.</p><pre>Loop:    for n := 0; n &lt; len(src); n += size {        switch {        case src[n] &lt; sizeOne:            if validateOnly {                break            }            size = 1            update(src[n])        case src[n] &lt; sizeTwo:            if n+1 &gt;= len(src) {                err = errShortInput                break Loop            }            if validateOnly {                break            }            size = 2            update(src[n] + src[n+1]&lt;&lt;shift)        }    }</pre><p>Of course, the <code>continue</code> statement also accepts an optional labelbut it applies only to loops.</p><p>To close this section, here's a comparison routine for byte slices that uses two<code>switch</code> statements:</p><pre>// Compare returns an integer comparing the two byte slices,// lexicographically.// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; bfunc Compare(a, b []byte) int {    for i := 0; i &lt; len(a) &amp;&amp; i &lt; len(b); i++ {        switch {        case a[i] &gt; b[i]:            return 1        case a[i] &lt; b[i]:            return -1        }    }    switch {    case len(a) &gt; len(b):        return 1    case len(a) &lt; len(b):        return -1    }    return 0}</pre><h3 id="type_switch">Type switch</h3><p>A switch can also be used to discover the dynamic type of an interfacevariable.  Such a <em>type switch</em> uses the syntax of a typeassertion with the keyword <code>type</code> inside the parentheses.If the switch declares a variable in the expression, the variable willhave the corresponding type in each clause.It's also idiomatic to reuse the name in such cases, in effect declaringa new variable with the same name but a different type in each case.</p><pre>var t interface{}t = functionOfSomeType()switch t := t.(type) {default:    fmt.Printf("unexpected type %T\n", t)     // %T prints whatever type t hascase bool:    fmt.Printf("boolean %t\n", t)             // t has type boolcase int:    fmt.Printf("integer %d\n", t)             // t has type intcase *bool:    fmt.Printf("pointer to boolean %t\n", *t) // t has type *boolcase *int:    fmt.Printf("pointer to integer %d\n", *t) // t has type *int}</pre><h2 id="functions">Functions</h2><h3 id="multiple-returns">Multiple return values</h3><p>One of Go's unusual features is that functions and methodscan return multiple values.  This form can be used toimprove on a couple of clumsy idioms in C programs: in-banderror returns such as <code>-1</code> for <code>EOF</code>and modifying an argument passed by address.</p><p>In C, a write error is signaled by a negative count with theerror code secreted away in a volatile location.In Go, <code>Write</code>can return a count <i>and</i> an error: &ldquo;Yes, you wrote somebytes but not all of them because you filled the device&rdquo;.The signature of the <code>Write</code> method on files frompackage <code>os</code> is:</p><pre>func (file *File) Write(b []byte) (n int, err error)</pre><p>and as the documentation says, it returns the number of byteswritten and a non-nil <code>error</code> when <code>n</code><code>!=</code> <code>len(b)</code>.This is a common style; see the section on error handling for more examples.</p><p>A similar approach obviates the need to pass a pointer to a returnvalue to simulate a reference parameter.Here's a simple-minded function tograb a number from a position in a byte slice, returning the numberand the next position.</p><pre>func nextInt(b []byte, i int) (int, int) {    for ; i &lt; len(b) &amp;&amp; !isDigit(b[i]); i++ {    }    x := 0    for ; i &lt; len(b) &amp;&amp; isDigit(b[i]); i++ {        x = x*10 + int(b[i]) - '0'    }    return x, i}</pre><p>You could use it to scan the numbers in an input slice <code>b</code> like this:</p><pre>    for i := 0; i &lt; len(b); {        x, i = nextInt(b, i)        fmt.Println(x)    }</pre><h3 id="named-results">Named result parameters</h3><p>The return or result "parameters" of a Go function can be given names andused as regular variables, just like the incoming parameters.When named, they are initialized to the zero values for their types whenthe function begins; if the function executes a <code>return</code> statementwith no arguments, the current values of the result parameters areused as the returned values.</p><p>The names are not mandatory but they can make code shorter and clearer:they're documentation.If we name the results of <code>nextInt</code> it becomesobvious which returned <code>int</code>is which.</p><pre>func nextInt(b []byte, pos int) (value, nextPos int) {</pre><p>Because named results are initialized and tied to an unadorned return, they can simplifyas well as clarify.  Here's a versionof <code>io.ReadFull</code> that uses them well:</p><pre>func ReadFull(r Reader, buf []byte) (n int, err error) {    for len(buf) &gt; 0 &amp;&amp; err == nil {        var nr int        nr, err = r.Read(buf)        n += nr        buf = buf[nr:]    }    return}</pre><h3 id="defer">Defer</h3><p>Go's <code>defer</code> statement schedules a function call (the<i>deferred</i> function) to be run immediately before the functionexecuting the <code>defer</code> returns.  It's an unusual buteffective way to deal with situations such as resources that must bereleased regardless of which path a function takes to return.  Thecanonical examples are unlocking a mutex or closing a file.</p><pre>// Contents returns the file's contents as a string.func Contents(filename string) (string, error) {    f, err := os.Open(filename)    if err != nil {        return "", err    }    defer f.Close()  // f.Close will run when we're finished.    var result []byte    buf := make([]byte, 100)    for {        n, err := f.Read(buf[0:])        result = append(result, buf[0:n]...) // append is discussed later.        if err != nil {            if err == io.EOF {                break            }            return "", err  // f will be closed if we return here.        }    }    return string(result), nil // f will be closed if we return here.}</pre><p>Deferring a call to a function such as <code>Close</code> has two advantages.  First, itguarantees that you will never forget to close the file, a mistakethat's easy to make if you later edit the function to add a new returnpath.  Second, it means that the close sits near the open,which is much clearer than placing it at the end of the function.</p><p>The arguments to the deferred function (which include the receiver ifthe function is a method) are evaluated when the <i>defer</i>executes, not when the <i>call</i> executes.  Besides avoiding worriesabout variables changing values as the function executes, this meansthat a single deferred call site can defer multiple functionexecutions.  Here's a silly example.</p><pre>for i := 0; i &lt; 5; i++ {    defer fmt.Printf("%d ", i)}</pre><p>Deferred functions are executed in LIFO order, so this code will cause<code>4 3 2 1 0</code> to be printed when the function returns.  Amore plausible example is a simple way to trace function executionthrough the program.  We could write a couple of simple tracingroutines like this:</p><pre>func trace(s string)   { fmt.Println("entering:", s) }func untrace(s string) { fmt.Println("leaving:", s) }// Use them like this:func a() {    trace("a")    defer untrace("a")    // do something....}</pre><p>We can do better by exploiting the fact that arguments to deferredfunctions are evaluated when the <code>defer</code> executes.  Thetracing routine can set up the argument to the untracing routine.This example:</p><pre>func trace(s string) string {    fmt.Println("entering:", s)    return s}func un(s string) {    fmt.Println("leaving:", s)}func a() {    defer un(trace("a"))    fmt.Println("in a")}func b() {    defer un(trace("b"))    fmt.Println("in b")    a()}func main() {    b()}</pre><p>prints</p><pre>entering: bin bentering: ain aleaving: aleaving: b</pre><p>For programmers accustomed to block-level resource management fromother languages, <code>defer</code> may seem peculiar, but its mostinteresting and powerful applications come precisely from the factthat it's not block-based but function-based.  In the section on<code>panic</code> and <code>recover</code> we'll see anotherexample of its possibilities.</p><h2 id="data">Data</h2><h3 id="allocation_new">Allocation with <code>new</code></h3><p>Go has two allocation primitives, the built-in functions<code>new</code> and <code>make</code>.They do different things and apply to different types, which can be confusing,but the rules are simple.Let's talk about <code>new</code> first.It's a built-in function that allocates memory, but unlike its namesakesin some other languages it does not <em>initialize</em> the memory,it only <em>zeros</em> it.That is,<code>new(T)</code> allocates zeroed storage for a new item of type<code>T</code> and returns its address, a value of type <code>*T</code>.In Go terminology, it returns a pointer to a newly allocated zero value of type<code>T</code>.</p><p>Since the memory returned by <code>new</code> is zeroed, it's helpful to arrangewhen designing your data structures that thezero value of each type can be used without further initialization.  This means a user ofthe data structure can create one with <code>new</code> and get right towork.For example, the documentation for <code>bytes.Buffer</code> states that"the zero value for <code>Buffer</code> is an empty buffer ready to use."Similarly, <code>sync.Mutex</code> does nothave an explicit constructor or <code>Init</code> method.Instead, the zero value for a <code>sync.Mutex</code>is defined to be an unlocked mutex.</p><p>The zero-value-is-useful property works transitively. Consider this type declaration.</p><pre>type SyncedBuffer struct {    lock    sync.Mutex    buffer  bytes.Buffer}</pre><p>Values of type <code>SyncedBuffer</code> are also ready to use immediately upon allocationor just declaration.  In the next snippet, both <code>p</code> and <code>v</code> will workcorrectly without further arrangement.</p><pre>p := new(SyncedBuffer)  // type *SyncedBuffervar v SyncedBuffer      // type  SyncedBuffer</pre><h3 id="composite_literals">Constructors and composite literals</h3><p>Sometimes the zero value isn't good enough and an initializingconstructor is necessary, as in this example derived frompackage <code>os</code>.</p><pre>func NewFile(fd int, name string) *File {    if fd &lt; 0 {        return nil    }    f := new(File)    f.fd = fd    f.name = name    f.dirinfo = nil    f.nepipe = 0    return f}</pre><p>There's a lot of boiler plate in there.  We can simplify itusing a <i>composite literal</i>, which isan expression that creates anew instance each time it is evaluated.</p><pre>func NewFile(fd int, name string) *File {    if fd &lt; 0 {        return nil    }    f := File{fd, name, nil, 0}    return &amp;f}</pre><p>Note that, unlike in C, it's perfectly OK to return the address of a local variable;the storage associated with the variable survives after the functionreturns.In fact, taking the address of a composite literalallocates a fresh instance each time it is evaluated,so we can combine these last two lines.</p><pre>    return &amp;File{fd, name, nil, 0}</pre><p>The fields of a composite literal are laid out in order and must all be present.However, by labeling the elements explicitly as <i>field</i><code>:</code><i>value</i>pairs, the initializers can appear in anyorder, with the missing ones left as their respective zero values.  Thus we could say</p><pre>    return &amp;File{fd: fd, name: name}</pre><p>As a limiting case, if a composite literal contains no fields at all, it createsa zero value for the type.  The expressions <code>new(File)</code> and <code>&amp;File{}</code> are equivalent.</p><p>Composite literals can also be created for arrays, slices, and maps,with the field labels being indices or map keys as appropriate.In these examples, the initializations work regardless of the values of <code>Enone</code>,<code>Eio</code>, and <code>Einval</code>, as long as they are distinct.</p><pre>a := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}s := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}</pre><h3 id="allocation_make">Allocation with <code>make</code></h3><p>Back to allocation.The built-in function <code>make(T, </code><i>args</i><code>)</code> servesa purpose different from <code>new(T)</code>.It creates slices, maps, and channels only, and it returns an <em>initialized</em>(not <em>zeroed</em>)value of type <code>T</code> (not <code>*T</code>).The reason for the distinctionis that these three types represent, under the covers, references to data structures thatmust be initialized before use.A slice, for example, is a three-item descriptorcontaining a pointer to the data (inside an array), the length, and thecapacity, and until those items are initialized, the slice is <code>nil</code>.For slices, maps, and channels,<code>make</code> initializes the internal data structure and preparesthe value for use.For instance,</p><pre>make([]int, 10, 100)</pre><p>allocates an array of 100 ints and then creates a slicestructure with length 10 and a capacity of 100 pointing at the first10 elements of the array.(When making a slice, the capacity can be omitted; see the section on slicesfor more information.)In contrast, <code>new([]int)</code> returns a pointer to a newly allocated, zeroed slicestructure, that is, a pointer to a <code>nil</code> slice value.</p><p>These examples illustrate the difference between <code>new</code> and<code>make</code>.</p><pre>var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely usefulvar v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints// Unnecessarily complex:var p *[]int = new([]int)*p = make([]int, 100, 100)// Idiomatic:v := make([]int, 100)</pre><p>Remember that <code>make</code> applies only to maps, slices and channelsand does not return a pointer.To obtain an explicit pointer allocate with <code>new</code> or take the addressof a variable explicitly.</p><h3 id="arrays">Arrays</h3><p>Arrays are useful when planning the detailed layout of memory and sometimescan help avoid allocation, but primarilythey are a building block for slices, the subject of the next section.To lay the foundation for that topic, here are a few words about arrays.</p><p>There are major differences between the ways arrays work in Go and C.In Go,</p><ul><li>Arrays are values. Assigning one array to another copies all the elements.</li><li>In particular, if you pass an array to a function, itwill receive a <i>copy</i> of the array, not a pointer to it.</li><li>The size of an array is part of its type.  The types <code>[10]int</code>and <code>[20]int</code> are distinct.</li></ul><p>The value property can be useful but also expensive; if you want C-like behavior and efficiency,you can pass a pointer to the array.</p><pre>func Sum(a *[3]float64) (sum float64) {    for _, v := range *a {        sum += v    }    return}array := [...]float64{7.0, 8.5, 9.1}x := Sum(&amp;array)  // Note the explicit address-of operator</pre><p>But even this style isn't idiomatic Go.Use slices instead.</p><h3 id="slices">Slices</h3><p>Slices wrap arrays to give a more general, powerful, and convenientinterface to sequences of data.  Except for items with explicitdimension such as transformation matrices, most array programming inGo is done with slices rather than simple arrays.</p><p>Slices hold references to an underlying array, and if you assign oneslice to another, both refer to the same array.If a function takes a slice argument, changes it makes tothe elements of the slice will be visible to the caller, analogous topassing a pointer to the underlying array.  A <code>Read</code>function can therefore accept a slice argument rather than a pointerand a count; the length within the slice sets an upperlimit of how much data to read.  Here is the signature of the<code>Read</code> method of the <code>File</code> type in package<code>os</code>:</p><pre>func (f *File) Read(buf []byte) (n int, err error)</pre><p>The method returns the number of bytes read and an error value, ifany.To read into the first 32 bytes of a larger buffer<code>buf</code>, <i>slice</i> (here used as a verb) the buffer.</p><pre>    n, err := f.Read(buf[0:32])</pre><p>Such slicing is common and efficient.  In fact, leaving efficiency aside forthe moment, the following snippet would also read the first 32 bytes of the buffer.</p><pre>    var n int    var err error    for i := 0; i &lt; 32; i++ {        nbytes, e := f.Read(buf[i:i+1])  // Read one byte.        n += nbytes        if nbytes == 0 || e != nil {            err = e            break        }    }</pre><p>The length of a slice may be changed as long as it still fits withinthe limits of the underlying array; just assign it to a slice ofitself.  The <i>capacity</i> of a slice, accessible by the built-infunction <code>cap</code>, reports the maximum length the slice mayassume.  Here is a function to append data to a slice.  If the dataexceeds the capacity, the slice is reallocated.  Theresulting slice is returned.  The function uses the fact that<code>len</code> and <code>cap</code> are legal when applied to the<code>nil</code> slice, and return 0.</p><pre>func Append(slice, data []byte) []byte {    l := len(slice)    if l + len(data) &gt; cap(slice) {  // reallocate        // Allocate double what's needed, for future growth.        newSlice := make([]byte, (l+len(data))*2)        // The copy function is predeclared and works for any slice type.        copy(newSlice, slice)        slice = newSlice    }    slice = slice[0:l+len(data)]    copy(slice[l:], data)    return slice}</pre><p>We must return the slice afterwards because, although <code>Append</code>can modify the elements of <code>slice</code>, the slice itself (the run-time datastructure holding the pointer, length, and capacity) is passed by value.</p><p>The idea of appending to a slice is so useful it's captured by the<code>append</code> built-in function.  To understand that function'sdesign, though, we need a little more information, so we'll returnto it later.</p><h3 id="two_dimensional_slices">Two-dimensional slices</h3><p>Go's arrays and slices are one-dimensional.To create the equivalent of a 2D array or slice, it is necessary to define an array-of-arraysor slice-of-slices, like this:</p><pre>type Transform [3][3]float64  // A 3x3 array, really an array of arrays.type LinesOfText [][]byte     // A slice of byte slices.</pre><p>Because slices are variable-length, it is possible to have each innerslice be a different length.That can be a common situation, as in our <code>LinesOfText</code>example: each line has an independent length.</p><pre>text := LinesOfText{    []byte("Now is the time"),    []byte("for all good gophers"),    []byte("to bring some fun to the party."),}</pre><p>Sometimes it's necessary to allocate a 2D slice, a situation that can arise whenprocessing scan lines of pixels, for instance.There are two ways to achieve this.One is to allocate each slice independently; the otheris to allocate a single array and point the individual slices into it.Which to use depends on your application.If the slices might grow or shrink, they should be allocated independentlyto avoid overwriting the next line; if not, it can be more efficient to constructthe object with a single allocation.For reference, here are sketches of the two methods.First, a line at a time:</p><pre>// Allocate the top-level slice.picture := make([][]uint8, YSize) // One row per unit of y.// Loop over the rows, allocating the slice for each row.for i := range picture {    picture[i] = make([]uint8, XSize)}</pre><p>And now as one allocation, sliced into lines:</p><pre>// Allocate the top-level slice, the same as before.picture := make([][]uint8, YSize) // One row per unit of y.// Allocate one large slice to hold all the pixels.pixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8.// Loop over the rows, slicing each row from the front of the remaining pixels slice.for i := range picture {    picture[i], pixels = pixels[:XSize], pixels[XSize:]}</pre><h3 id="maps">Maps</h3><p>Maps are a convenient and powerful built-in data structure that associatevalues of one type (the <em>key</em>) with values of another type(the <em>element</em> or <em>value</em>).The key can be of any type for which the equality operator is defined,such as integers,floating point and complex numbers,strings, pointers, interfaces (as long as the dynamic typesupports equality), structs and arrays.Slices cannot be used as map keys,because equality is not defined on them.Like slices, maps hold references to an underlying data structure.If you pass a map to a functionthat changes the contents of the map, the changes will be visiblein the caller.</p><p>Maps can be constructed using the usual composite literal syntaxwith colon-separated key-value pairs,so it's easy to build them during initialization.</p><pre>var timeZone = map[string]int{    "UTC":  0*60*60,    "EST": -5*60*60,    "CST": -6*60*60,    "MST": -7*60*60,    "PST": -8*60*60,}</pre><p>Assigning and fetching map values looks syntactically just likedoing the same for arrays and slices except that the index doesn'tneed to be an integer.</p><pre>offset := timeZone["EST"]</pre><p>An attempt to fetch a map value with a key thatis not present in the map will return the zero value for the typeof the entriesin the map.  For instance, if the map contains integers, lookingup a non-existent key will return <code>0</code>.A set can be implemented as a map with value type <code>bool</code>.Set the map entry to <code>true</code> to put the value in the set, and thentest it by simple indexing.</p><pre>attended := map[string]bool{    "Ann": true,    "Joe": true,    ...}<p>if attended[person] { // will be false if person is not in the map<br>    fmt.Println(person, “was at the meeting”)<br>}</p></pre><p></p><p>Sometimes you need to distinguish a missing entry froma zero value.  Is there an entry for <code>"UTC"</code>or is that 0 because it's not in the map at all?You can discriminate with a form of multiple assignment.</p><pre>var seconds intvar ok boolseconds, ok = timeZone[tz]</pre><p>For obvious reasons this is called the &ldquo;comma ok&rdquo; idiom.In this example, if <code>tz</code> is present, <code>seconds</code>will be set appropriately and <code>ok</code> will be true; if not,<code>seconds</code> will be set to zero and <code>ok</code> willbe false.Here's a function that puts it together with a nice error report:</p><pre>func offset(tz string) int {    if seconds, ok := timeZone[tz]; ok {        return seconds    }    log.Println("unknown time zone:", tz)    return 0}</pre><p>To test for presence in the map without worrying about the actual value,you can use the <a href="#blank">blank identifier</a> (<code>_</code>)in place of the usual variable for the value.</p><pre>_, present := timeZone[tz]</pre><p>To delete a map entry, use the <code>delete</code>built-in function, whose arguments are the map and the key to be deleted.It's safe to do this even if the key is already absentfrom the map.</p><pre>delete(timeZone, "PDT")  // Now on Standard Time</pre><h3 id="printing">Printing</h3><p>Formatted printing in Go uses a style similar to C's <code>printf</code>family but is richer and more general. The functions live in the <code>fmt</code>package and have capitalized names: <code>fmt.Printf</code>, <code>fmt.Fprintf</code>,<code>fmt.Sprintf</code> and so on.  The string functions (<code>Sprintf</code> etc.)return a string rather than filling in a provided buffer.</p><p>You don't need to provide a format string.  For each of <code>Printf</code>,<code>Fprintf</code> and <code>Sprintf</code> there is another pairof functions, for instance <code>Print</code> and <code>Println</code>.These functions do not take a format string but instead generate a defaultformat for each argument. The <code>Println</code> versions also insert a blankbetween arguments and append a newline to the output whilethe <code>Print</code> versions add blanks only if the operand on neither side is a string.In this example each line produces the same output.</p><pre>fmt.Printf("Hello %d\n", 23)fmt.Fprint(os.Stdout, "Hello ", 23, "\n")fmt.Println("Hello", 23)fmt.Println(fmt.Sprint("Hello ", 23))</pre><p>The formatted print functions <code>fmt.Fprint</code>and friends take as a first argument any objectthat implements the <code>io.Writer</code> interface; the variables <code>os.Stdout</code>and <code>os.Stderr</code> are familiar instances.</p><p>Here things start to diverge from C.  First, the numeric formats such as <code>%d</code>do not take flags for signedness or size; instead, the printing routines use thetype of the argument to decide these properties.</p><pre>var x uint64 = 1&lt;&lt;64 - 1fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))</pre><p>prints</p><pre>18446744073709551615 ffffffffffffffff; -1 -1</pre><p>If you just want the default conversion, such as decimal for integers, you can usethe catchall format <code>%v</code> (for &ldquo;value&rdquo;); the result is exactlywhat <code>Print</code> and <code>Println</code> would produce.Moreover, that format can print <em>any</em> value, even arrays, slices, structs, andmaps.  Here is a print statement for the time zone map defined in the previous section.</p><pre>fmt.Printf("%v\n", timeZone)  // or just fmt.Println(timeZone)</pre><p>which gives output:</p><pre>map[CST:-21600 EST:-18000 MST:-25200 PST:-28800 UTC:0]</pre><p>For maps, <code>Printf</code> and friends sort the output lexicographically by key.</p><p>When printing a struct, the modified format <code>%+v</code> annotates thefields of the structure with their names, and for any value the alternateformat <code>%#v</code> prints the value in full Go syntax.</p><pre>type T struct {    a int    b float64    c string}t := &amp;T{ 7, -2.35, "abc\tdef" }fmt.Printf("%v\n", t)fmt.Printf("%+v\n", t)fmt.Printf("%#v\n", t)fmt.Printf("%#v\n", timeZone)</pre><p>prints</p><pre>&amp;{7 -2.35 abc   def}&amp;{a:7 b:-2.35 c:abc     def}&amp;main.T{a:7, b:-2.35, c:"abc\tdef"}map[string]int{"CST":-21600, "EST":-18000, "MST":-25200, "PST":-28800, "UTC":0}</pre><p>(Note the ampersands.)That quoted string format is also available through <code>%q</code> whenapplied to a value of type <code>string</code> or <code>[]byte</code>.The alternate format <code>%#q</code> will use backquotes instead if possible.(The <code>%q</code> format also applies to integers and runes, producing asingle-quoted rune constant.)Also, <code>%x</code> works on strings, byte arrays and byte slices as well ason integers, generating a long hexadecimal string, and witha space in the format (<code>%&nbsp;x</code>) it puts spaces between the bytes.</p><p>Another handy format is <code>%T</code>, which prints the <em>type</em> of a value.</p><pre>fmt.Printf(&quot;%T\n&quot;, timeZone)</pre><p>prints</p><pre>map[string]int</pre><p>If you want to control the default format for a custom type, all that's required is to definea method with the signature <code>String() string</code> on the type.For our simple type <code>T</code>, that might look like this.</p><pre>func (t *T) String() string {    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)}fmt.Printf("%v\n", t)</pre><p>to print in the format</p><pre>7/-2.35/"abc\tdef"</pre><p>(If you need to print <em>values</em> of type <code>T</code> as well as pointers to <code>T</code>,the receiver for <code>String</code> must be of value type; this example used a pointer becausethat's more efficient and idiomatic for struct types.See the section below on <a href="#pointers_vs_values">pointers vs. value receivers</a> for more information.)</p><p>Our <code>String</code> method is able to call <code>Sprintf</code> because theprint routines are fully reentrant and can be wrapped this way.There is one important detail to understand about this approach,however: don't construct a <code>String</code> method by calling<code>Sprintf</code> in a way that will recur into your <code>String</code>method indefinitely.  This can happen if the <code>Sprintf</code>call attempts to print the receiver directly as a string, which inturn will invoke the method again.  It's a common and easy mistaketo make, as this example shows.</p><pre>type MyString stringfunc (m MyString) String() string {    return fmt.Sprintf("MyString=%s", m) // Error: will recur forever.}</pre><p>It's also easy to fix: convert the argument to the basic string type, which does not have themethod.</p><pre>type MyString stringfunc (m MyString) String() string {    return fmt.Sprintf("MyString=%s", string(m)) // OK: note conversion.}</pre><p>In the <a href="#initialization">initialization section</a> we'll see another technique that avoids this recursion.</p><p>Another printing technique is to pass a print routine's arguments directly to another such routine.The signature of <code>Printf</code> uses the type <code>...interface{}</code>for its final argument to specify that an arbitrary number of parameters (of arbitrary type)can appear after the format.</p><pre>func Printf(format string, v ...interface{}) (n int, err error) {</pre><p>Within the function <code>Printf</code>, <code>v</code> acts like a variable of type<code>[]interface{}</code> but if it is passed to another variadic function, it acts likea regular list of arguments.Here is the implementation of thefunction <code>log.Println</code> we used above. It passes its arguments directly to<code>fmt.Sprintln</code> for the actual formatting.</p><pre>// Println prints to the standard logger in the manner of fmt.Println.func Println(v ...interface{}) {    std.Output(2, fmt.Sprintln(v...))  // Output takes parameters (int, string)}</pre><p>We write <code>...</code> after <code>v</code> in the nested call to <code>Sprintln</code> to tell thecompiler to treat <code>v</code> as a list of arguments; otherwise it would just pass<code>v</code> as a single slice argument.</p><p>There's even more to printing than we've covered here.  See the <code>godoc</code> documentationfor package <code>fmt</code> for the details.</p><p>By the way, a <code>...</code> parameter can be of a specific type, for instance <code>...int</code>for a min function that chooses the least of a list of integers:</p><pre>func Min(a ...int) int {    min := int(^uint(0) &gt;&gt; 1)  // largest int    for _, i := range a {        if i &lt; min {            min = i        }    }    return min}</pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go 1.12发布说明</title>
      <link href="/go_1.12/"/>
      <url>/go_1.12/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  The latest Go release, version 1.12, arrives six months after <a href="go1.11">Go 1.11</a>.  Most of its changes are in the implementation of the toolchain, runtime, and libraries.<br>  As always, the release maintains the Go 1 <a href="/doc/go1compat">promise of compatibility</a>.  We expect almost all Go programs to continue to compile and run as before.</p><h2 id="language">Changes to the language</h2><p>  There are no changes to the language specification.</p><h2 id="ports">Ports</h2><p><!-- CL 138675 -->  The race detector is now supported on <code>linux/arm64</code>.</p><p id="freebsd">  Go 1.12 is the last release that is supported on FreeBSD 10.x, which has  already reached end-of-life. Go 1.13 will require FreeBSD 11.2+ or FreeBSD  12.0+.  FreeBSD 12.0+ requires a kernel with the COMPAT_FREEBSD11 option set (this is the default).</p><p><!-- CL 146898 -->  cgo is now supported on <code>linux/ppc64</code>.</p><p id="hurd"><!-- CL 146023 -->  <code>hurd</code> is now a recognized value for <code>GOOS</code>, reserved  for the GNU/Hurd system for use with <code>gccgo</code>.</p><h3 id="windows">Windows</h3><p>  Go's new <code>windows/arm</code> port supports running Go on Windows 10  IoT Core on 32-bit ARM chips such as the Raspberry Pi 3.</p><h3 id="aix">AIX</h3><p>  Go now supports AIX 7.2 and later on POWER8 architectures (<code>aix/ppc64</code>). External linking, cgo, pprof and the race detector aren't yet supported.</p><h3 id="darwin">Darwin</h3><p>  Go 1.12 is the last release that will run on macOS 10.10 Yosemite.  Go 1.13 will require macOS 10.11 El Capitan or later.</p><p><!-- CL 141639 -->  <code>libSystem</code> is now used when making syscalls on Darwin,  ensuring forward-compatibility with future versions of macOS and iOS.  <!-- CL 153338 -->  The switch to <code>libSystem</code> triggered additional App Store  checks for private API usage. Since it is considered private,  <code>syscall.Getdirentries</code> now always fails with  <code>ENOSYS</code> on iOS.</p><h2 id="tools">Tools</h2><h3 id="vet"><code>go tool vet</code> no longer supported</h3><p>  The <code>go vet</code> command has been rewritten to serve as the  base for a range of different source code analysis tools. See  the <a href="https://godoc.org/golang.org/x/tools/go/analysis" target="_blank" rel="noopener">golang.org/x/tools/go/analysis</a>  package for details. A side-effect is that <code>go tool vet</code>  is no longer supported. External tools that use <code>go tool  vet</code> must be changed to use <code>go  vet</code>. Using <code>go vet</code> instead of <code>go tool  vet</code> should work with all supported versions of Go.</p><p>  As part of this change, the experimental <code>-shadow</code> option  is no longer available with <code>go vet</code>. Checking for  variable shadowing may now be done using<pre>go get -u golang.org/x/tools/go/analysis/passes/shadow/cmd/shadowgo vet -vettool=$(which shadow)</pre></p><h3 id="tour">Tour</h3><p> <!-- CL 152657 -->The Go tour is no longer included in the main binary distribution. Torun the tour locally, instead of running <code>go</code> <code>tool</code> <code>tour</code>,manually install it:<pre>go get -u golang.org/x/tourtour</pre></p><h3 id="gocache">Build cache requirement</h3><p>  The <a href="/cmd/go/#hdr-Build_and_test_caching">build cache</a> is now  required as a step toward eliminating  <code>$GOPATH/pkg</code>. Setting the environment variable  <code>GOCACHE=off</code> will cause <code>go</code> commands that write to the  cache to fail.</p><h3 id="binary-only">Binary-only packages</h3><p>  Go 1.12 is the last release that will support binary-only packages.</p><h3 id="cgo">Cgo</h3><p>    Go 1.12 will translate the C type <code>EGLDisplay</code> to the Go type <code>uintptr</code>.    This change is similar to how Go 1.10 and newer treats Darwin's CoreFoundation    and Java's JNI types. See the    <a href="/cmd/cgo/#hdr-Special_cases">cgo documentation</a>    for more information.</p><p><!-- CL 152657 -->  Mangled C names are no longer accepted in packages that use Cgo. Use the Cgo  names instead. For example, use the documented cgo name <code>C.char</code>  rather than the mangled name <code>_Ctype_char</code> that cgo generates.</p><h3 id="modules">Modules</h3><p><!-- CL 148517 -->  When <code>GO111MODULE</code> is set to <code>on</code>, the <code>go</code>  command now supports module-aware operations outside of a module directory,  provided that those operations do not need to resolve import paths relative to  the current directory or explicitly edit the <code>go.mod</code> file.  Commands such as <code>go</code> <code>get</code>,  <code>go</code> <code>list</code>, and  <code>go</code> <code>mod</code> <code>download</code> behave as if in a  module with initially-empty requirements.  In this mode, <code>go</code> <code>env</code> <code>GOMOD</code> reports  the system's null device (<code>/dev/null</code> or <code>NUL</code>).</p><p><!-- CL 146382 -->  <code>go</code> commands that download and extract modules are now safe to  invoke concurrently.  The module cache (<code>GOPATH/pkg/mod</code>) must reside in a filesystem that  supports file locking.</p><p><!-- CL 147282, 147281 -->  The <code>go</code> directive in a <code>go.mod</code> file now indicates the  version of the language used by the files within that module.  It will be set to the current release  (<code>go</code> <code>1.12</code>) if no existing version is  present.  If the <code>go</code> directive for a module specifies a  version <em>newer</em> than the toolchain in use, the <code>go</code> command  will attempt to build the packages regardless, and will note the mismatch only if  that build fails.</p><p><!-- CL 147282, 147281 -->  This changed use of the <code>go</code> directive means that if you  use Go 1.12 to build a module, thus recording <code>go 1.12</code>  in the <code>go.mod</code> file, you will get an error when  attempting to build the same module with Go 1.11 through Go 1.11.3.  Go 1.11.4 or later will work fine, as will releases older than Go 1.11.  If you must use Go 1.11 through 1.11.3, you can avoid the problem by  setting the language version to 1.11, using the Go 1.12 go tool,  via <code>go mod edit -go=1.11</code>.</p><p><!-- CL 152739 -->  When an import cannot be resolved using the active modules,  the <code>go</code> command will now try to use the modules mentioned in the  main module's <code>replace</code> directives before consulting the module  cache and the usual network sources.  If a matching replacement is found but the <code>replace</code> directive does  not specify a version, the <code>go</code> command uses a pseudo-version  derived from the zero <code>time.Time</code> (such  as <code>v0.0.0-00010101000000-000000000000</code>).</p><h3 id="compiler">Compiler toolchain</h3><p><!-- CL 134155, 134156 -->  The compiler's live variable analysis has improved. This may mean that  finalizers will be executed sooner in this release than in previous  releases. If that is a problem, consider the appropriate addition of a  <a href="/pkg/runtime/#KeepAlive"><code>runtime.KeepAlive</code></a> call.</p><p><!-- CL 147361 -->  More functions are now eligible for inlining by default, including  functions that do nothing but call another function.  This extra inlining makes it additionally important to use  <a href="/pkg/runtime/#CallersFrames"><code>runtime.CallersFrames</code></a>  instead of iterating over the result of  <a href="/pkg/runtime/#Callers"><code>runtime.Callers</code></a> directly.<pre>// Old code which no longer works correctly (it will miss inlined call frames).var pcs [10]uintptrn := runtime.Callers(1, pcs[:])for _, pc := range pcs[:n] {    f := runtime.FuncForPC(pc)    if f != nil {        fmt.Println(f.Name())    }}</pre><pre>// New code which will work correctly.var pcs [10]uintptrn := runtime.Callers(1, pcs[:])frames := runtime.CallersFrames(pcs[:n])for {    frame, more := frames.Next()    fmt.Println(frame.Function)    if !more {        break    }}</pre></p><p><!-- CL 153477 -->  Wrappers generated by the compiler to implement method expressions  are no longer reported  by <a href="/pkg/runtime/#CallersFrames"><code>runtime.CallersFrames</code></a>  and <a href="/pkg/runtime/#Stack"><code>runtime.Stack</code></a>. They  are also not printed in panic stack traces.</p><p>  This change aligns the <code>gc</code> toolchain to match<br>  the <code>gccgo</code> toolchain, which already elided such wrappers<br>  from stack traces.</p><p>  Clients of these APIs might need to adjust for the missing<br>  frames. For code that must interoperate between 1.11 and 1.12<br>  releases, you can replace the method expression <code>x.M</code><br>  with the function literal <code>func (...) { x.M(...) } </code>.</p><p></p><p><!-- CL 144340 -->  The compiler now accepts a <code>-lang</code> flag to set the Go language  version to use. For example, <code>-lang=go1.8</code> causes the compiler to  emit an error if the program uses type aliases, which were added in Go 1.9.  Language changes made before Go 1.12 are not consistently enforced.</p><p><!-- CL 147160 -->  The compiler toolchain now uses different conventions to call Go  functions and assembly functions. This should be invisible to users,  except for calls that simultaneously cross between Go and  assembly <em>and</em> cross a package boundary. If linking results  in an error like "relocation target not defined for ABIInternal (but  is defined for ABI0)", please refer to the  <a href="https://github.com/golang/proposal/blob/master/design/27539-internal-abi.md#compatibility" target="_blank" rel="noopener">compatibility section</a>  of the ABI design document.</p><p><!-- CL 145179 -->  There have been many improvements to the DWARF debug information  produced by the compiler, including improvements to argument  printing and variable location information.</p><p><!-- CL 61511 -->  Go programs now also maintain stack frame pointers on <code>linux/arm64</code>  for the benefit of profiling tools like <code>perf</code>. The frame pointer  maintenance has a small run-time overhead that varies but averages around 3%.  To build a toolchain that does not use frame pointers, set  <code>GOEXPERIMENT=noframepointer</code> when running <code>make.bash</code>.</p><p><!-- CL 142717 -->  The obsolete "safe" compiler mode (enabled by the <code>-u</code> gcflag) has been removed.</p><h3 id="godoc"><code>godoc</code> and <code>go</code> <code>doc</code></h3><p>  In Go 1.12, <code>godoc</code> no longer has a command-line interface and  is only a web server. Users should use <code>go</code> <code>doc</code>  for command-line help output instead. Go 1.12 is the last release that will  include the <code>godoc</code> webserver; in Go 1.13 it will be available  via <code>go</code> <code>get</code>.</p><p><!-- CL 141977 -->  <code>go</code> <code>doc</code> now supports the <code>-all</code> flag,  which will cause it to print all exported APIs and their documentation,  as the <code>godoc</code> command line used to do.</p><p><!-- CL 140959 -->  <code>go</code> <code>doc</code> also now includes the <code>-src</code> flag,  which will show the target's source code.</p><h3 id="trace">Trace</h3><p><!-- CL 60790 -->  The trace tool now supports plotting mutator utilization curves,  including cross-references to the execution trace. These are useful  for analyzing the impact of the garbage collector on application  latency and throughput.</p><h3 id="assembler">Assembler</h3><p><!-- CL 147218 -->  On <code>arm64</code>, the platform register was renamed from  <code>R18</code> to <code>R18_PLATFORM</code> to prevent accidental  use, as the OS could choose to reserve this register.</p><h2 id="runtime">Runtime</h2><p><!-- CL 138959 -->  Go 1.12 significantly improves the performance of sweeping when a  large fraction of the heap remains live. This reduces allocation  latency immediately following a garbage collection.</p><p><!-- CL 139719 -->  The Go runtime now releases memory back to the operating system more  aggressively, particularly in response to large allocations that  can't reuse existing heap space.</p><p><!-- CL 146342, CL 146340, CL 146345, CL 146339, CL 146343, CL 146337, CL 146341, CL 146338 -->  The Go runtime's timer and deadline code is faster and scales better  with higher numbers of CPUs. In particular, this improves the  performance of manipulating network connection deadlines.</p><p><!-- CL 135395 -->  On Linux, the runtime now uses <code>MADV_FREE</code> to release unused  memory. This is more efficient but may result in higher reported  RSS. The kernel will reclaim the unused data when it is needed.  To revert to the Go 1.11 behavior (<code>MADV_DONTNEED</code>), set the  environment variable <code>GODEBUG=madvdontneed=1</code>.</p><p><!-- CL 149578 -->  Adding cpu.<em>extension</em>=off to the  <a href="/doc/diagnostics.html#godebug">GODEBUG</a> environment  variable now disables the use of optional CPU instruction  set extensions in the standard library and runtime. This is not  yet supported on Windows.</p><p><!-- CL 158337 -->  Go 1.12 improves the accuracy of memory profiles by fixing  overcounting of large heap allocations.</p><p><!-- CL 159717 -->  Tracebacks, <code>runtime.Caller</code>,  and <code>runtime.Callers</code> no longer include  compiler-generated initialization functions.  Doing a traceback  during the initialization of a global variable will now show a  function named <code>PKG.init.ializers</code>.</p><h2 id="library">Core library</h2><h3 id="tls_1_3">TLS 1.3</h3><p>  Go 1.12 adds opt-in support for TLS 1.3 in the <code>crypto/tls</code> package as  specified by <a href="https://www.rfc-editor.org/info/rfc8446" target="_blank" rel="noopener">RFC 8446</a>. It can  be enabled by adding the value <code>tls13=1</code> to the <code>GODEBUG</code>  environment variable. It will be enabled by default in Go 1.13.</p><p>  To negotiate TLS 1.3, make sure you do not set an explicit <code>MaxVersion</code> in  <a href="/pkg/crypto/tls/#Config"><code>Config</code></a> and run your program with  the environment variable <code>GODEBUG=tls13=1</code> set.</p><p>  All TLS 1.2 features except <code>TLSUnique</code> in  <a href="/pkg/crypto/tls/#ConnectionState"><code>ConnectionState</code></a>  and renegotiation are available in TLS 1.3 and provide equivalent or  better security and performance. Note that even though TLS 1.3 is backwards  compatible with previous versions, certain legacy systems might not work  correctly when attempting to negotiate it. RSA certificate keys too small  to be secure (including 512-bit keys) will not work with TLS 1.3.</p><p>  TLS 1.3 cipher suites are not configurable. All supported cipher suites are  safe, and if <code>PreferServerCipherSuites</code> is set in  <a href="/pkg/crypto/tls/#Config"><code>Config</code></a> the preference order  is based on the available hardware.</p><p>  Early data (also called "0-RTT mode") is not currently supported as a  client or server. Additionally, a Go 1.12 server does not support skipping  unexpected early data if a client sends it. Since TLS 1.3 0-RTT mode  involves clients keeping state regarding which servers support 0-RTT,  a Go 1.12 server cannot be part of a load-balancing pool where some other  servers do support 0-RTT. If switching a domain from a server that supported  0-RTT to a Go 1.12 server, 0-RTT would have to be disabled for at least the  lifetime of the issued session tickets before the switch to ensure  uninterrupted operation.</p><p>  In TLS 1.3 the client is the last one to speak in the handshake, so if it causes  an error to occur on the server, it will be returned on the client by the first  <a href="/pkg/crypto/tls/#Conn.Read"><code>Read</code></a>, not by  <a href="/pkg/crypto/tls/#Conn.Handshake"><code>Handshake</code></a>. For  example, that will be the case if the server rejects the client certificate.  Similarly, session tickets are now post-handshake messages, so are only  received by the client upon its first  <a href="/pkg/crypto/tls/#Conn.Read"><code>Read</code></a>.</p><h3 id="minor_library_changes">Minor changes to the library</h3><p>  As always, there are various minor changes and updates to the library,  made with the Go 1 <a href="/doc/go1compat">promise of compatibility</a>  in mind.</p><!-- TODO: CL 115677: https://golang.org/cl/115677: cmd/vet: check embedded field tags too --><dl id="bufio"><dt><a href="/pkg/bufio/">bufio</a></dt>  <dd>    <p><!-- CL 149297 -->      <code>Reader</code>'s <a href="/pkg/bufio/#Reader.UnreadRune"><code>UnreadRune</code></a> and      <a href="/pkg/bufio/#Reader.UnreadByte"><code>UnreadByte</code></a> methods will now return an error      if they are called after <a href="/pkg/bufio/#Reader.Peek"><code>Peek</code></a>.    </p></dd></dl><!-- bufio --><dl id="bytes"><dt><a href="/pkg/bytes/">bytes</a></dt>  <dd>    <p><!-- CL 137855 -->      The new function <a href="/pkg/bytes/#ReplaceAll"><code>ReplaceAll</code></a> returns a copy of      a byte slice with all non-overlapping instances of a value replaced by another.    </p><pre><code>&lt;p&gt;&lt;!-- CL 145098 --&gt;  A pointer to a zero-value &lt;a href=&quot;/pkg/bytes/#Reader&quot;&gt;&lt;code&gt;Reader&lt;/code&gt;&lt;/a&gt; is now  functionally equivalent to &lt;a href=&quot;/pkg/bytes/#NewReader&quot;&gt;&lt;code&gt;NewReader&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(nil)&lt;/code&gt;.  Prior to Go 1.12, the former could not be used as a substitute for the latter in all cases.&lt;/p&gt;</code></pre></dd></dl><!-- bytes --><dl id="crypto/rand"><dt><a href="/pkg/crypto/rand/">crypto/rand</a></dt>  <dd>    <p><!-- CL 139419 -->      A warning will now be printed to standard error the first time      <code>Reader.Read</code> is blocked for more than 60 seconds waiting      to read entropy from the kernel.    </p><pre><code>&lt;p&gt;&lt;!-- CL 120055 --&gt;  On FreeBSD, &lt;code&gt;Reader&lt;/code&gt; now uses the &lt;code&gt;getrandom&lt;/code&gt;  system call if available, &lt;code&gt;/dev/urandom&lt;/code&gt; otherwise.&lt;/p&gt;</code></pre></dd></dl><!-- crypto/rand --><dl id="crypto/rc4"><dt><a href="/pkg/crypto/rc4/">crypto/rc4</a></dt>  <dd>    <p><!-- CL 130397 -->      This release removes the assembly implementations, leaving only      the pure Go version. The Go compiler generates code that is      either slightly better or slightly worse, depending on the exact      CPU. RC4 is insecure and should only be used for compatibility      with legacy systems.    </p></dd></dl><!-- crypto/rc4 --><dl id="crypto/tls"><dt><a href="/pkg/crypto/tls/">crypto/tls</a></dt>  <dd>    <p><!-- CL 143177 -->      If a client sends an initial message that does not look like TLS, the server      will no longer reply with an alert, and it will expose the underlying      <code>net.Conn</code> in the new field <code>Conn</code> of      <a href="/pkg/crypto/tls/#RecordHeaderError"><code>RecordHeaderError</code></a>.    </p></dd></dl><!-- crypto/tls --><dl id="database/sql"><dt><a href="/pkg/database/sql/">database/sql</a></dt>  <dd>    <p><!-- CL 145738 -->      A query cursor can now be obtained by passing a      <a href="/pkg/database/sql/#Rows"><code>*Rows</code></a>      value to the <a href="/pkg/database/sql/#Row.Scan"><code>Row.Scan</code></a> method.    </p></dd></dl><!-- database/sql --><dl id="expvar"><dt><a href="/pkg/expvar/">expvar</a></dt>  <dd>    <p><!-- CL 139537 -->      The new <a href="/pkg/expvar/#Map.Delete"><code>Delete</code></a> method allows      for deletion of key/value pairs from a <a href="/pkg/expvar/#Map"><code>Map</code></a>.    </p></dd></dl><!-- expvar --><dl id="fmt"><dt><a href="/pkg/fmt/">fmt</a></dt>  <dd>    <p><!-- CL 142737 -->      Maps are now printed in key-sorted order to ease testing. The ordering rules are:      <ul>        <li>When applicable, nil compares low        </li><li>ints, floats, and strings order by <        </li><li>NaN compares less than non-NaN floats        </li><li>bool compares false before true        </li><li>Complex compares real, then imaginary        </li><li>Pointers compare by machine address        </li><li>Channel values compare by machine address        </li><li>Structs compare each field in turn        </li><li>Arrays compare each element in turn        </li><li>Interface values compare first by <code>reflect.Type</code> describing the concrete type            and then by concrete value as described in the previous rules.      </li></ul>    </p><pre><code>&lt;p&gt;&lt;!-- CL 129777 --&gt;  When printing maps, non-reflexive key values like &lt;code&gt;NaN&lt;/code&gt; were previously  displayed as &lt;code&gt;&amp;lt;nil&amp;gt;&lt;/code&gt;. As of this release, the correct values are printed.&lt;/p&gt;</code></pre></dd></dl><!-- fmt --><dl id="go/doc"><dt><a href="/pkg/go/doc/">go/doc</a></dt>  <dd>    <p><!-- CL 140958 -->      To address some outstanding issues in <a href="/cmd/doc/"><code>cmd/doc</code></a>,      this package has a new <a href="/pkg/go/doc/#Mode"><code>Mode</code></a> bit,      <code>PreserveAST</code>, which controls whether AST data is cleared.    </p></dd></dl><!-- go/doc --><dl id="go/token"><dt><a href="/pkg/go/token/">go/token</a></dt>  <dd>    <p><!-- CL 134075 -->      The <a href="/pkg/go/token#File"><code>File</code></a> type has a new      <a href="/pkg/go/token#File.LineStart"><code>LineStart</code></a> field,      which returns the position of the start of a given line. This is especially useful      in programs that occasionally handle non-Go files, such as assembly, but wish to use      the <code>token.Pos</code> mechanism to identify file positions.    </p></dd></dl><!-- go/token --><dl id="image"><dt><a href="/pkg/image/">image</a></dt>  <dd>    <p><!-- CL 118755 -->      The <a href="/pkg/image/#RegisterFormat"><code>RegisterFormat</code></a> function is now safe for concurrent use.    </p></dd></dl><!-- image --><dl id="image/png"><dt><a href="/pkg/image/png/">image/png</a></dt>  <dd>    <p><!-- CL 134235 -->      Paletted images with fewer than 16 colors now encode to smaller outputs.    </p></dd></dl><!-- image/png --><dl id="io"><dt><a href="/pkg/io/">io</a></dt>  <dd>    <p><!-- CL 139457 -->      The new <a href="/pkg/io#StringWriter"><code>StringWriter</code></a> interface wraps the      <a href="/pkg/io/#WriteString"><code>WriteString</code></a> function.    </p></dd></dl><!-- io --><dl id="math"><dt><a href="/pkg/math/">math</a></dt>  <dd>    <p><!-- CL 153059 -->      The functions      <a href="/pkg/math/#Sin"><code>Sin</code></a>,      <a href="/pkg/math/#Cos"><code>Cos</code></a>,      <a href="/pkg/math/#Tan"><code>Tan</code></a>,      and <a href="/pkg/math/#Sincos"><code>Sincos</code></a> now      apply Payne-Hanek range reduction to huge arguments. This      produces more accurate answers, but they will not be bit-for-bit      identical with the results in earlier releases.    </p></dd></dl><!-- math --><dl id="math/bits"><dt><a href="/pkg/math/bits/">math/bits</a></dt>  <dd>    <p><!-- CL 123157 -->    New extended precision operations <a href="/pkg/math/bits/#Add"><code>Add</code></a>, <a href="/pkg/math/bits/#Sub"><code>Sub</code></a>, <a href="/pkg/math/bits/#Mul"><code>Mul</code></a>, and <a href="/pkg/math/bits/#Div"><code>Div</code></a> are available in <code>uint</code>, <code>uint32</code>, and <code>uint64</code> versions.    </p></dd></dl><!-- math/bits --><dl id="net"><dt><a href="/pkg/net/">net</a></dt>  <dd>    <p><!-- CL 146659 -->      The      <a href="/pkg/net/#Dialer.DualStack"><code>Dialer.DualStack</code></a> setting is now ignored and deprecated;      RFC 6555 Fast Fallback ("Happy Eyeballs") is now enabled by default. To disable, set      <a href="/pkg/net/#Dialer.FallbackDelay"><code>Dialer.FallbackDelay</code></a> to a negative value.    </p><pre><code>&lt;p&gt;&lt;!-- CL 107196 --&gt;  Similarly, TCP keep-alives are now enabled by default if  &lt;a href=&quot;/pkg/net/#Dialer.KeepAlive&quot;&gt;&lt;code&gt;Dialer.KeepAlive&lt;/code&gt;&lt;/a&gt; is zero.  To disable, set it to a negative value.&lt;/p&gt;&lt;p&gt;&lt;!-- CL 113997 --&gt;  On Linux, the &lt;a href=&quot;http://man7.org/linux/man-pages/man2/splice.2.html&quot;&gt;&lt;code&gt;splice&lt;/code&gt; system call&lt;/a&gt; is now used when copying from a  &lt;a href=&quot;/pkg/net/#UnixConn&quot;&gt;&lt;code&gt;UnixConn&lt;/code&gt;&lt;/a&gt; to a  &lt;a href=&quot;/pkg/net/#TCPConn&quot;&gt;&lt;code&gt;TCPConn&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;</code></pre></dd></dl><!-- net --><dl id="net/http"><dt><a href="/pkg/net/http/">net/http</a></dt>  <dd>    <p><!-- CL 143177 -->      The HTTP server now rejects misdirected HTTP requests to HTTPS servers with a plaintext "400 Bad Request" response.    </p><pre><code>&lt;p&gt;&lt;!-- CL 130115 --&gt;  The new &lt;a href=&quot;/pkg/net/http/#Client.CloseIdleConnections&quot;&gt;&lt;code&gt;Client.CloseIdleConnections&lt;/code&gt;&lt;/a&gt;  method calls the &lt;code&gt;Client&lt;/code&gt;&apos;s underlying &lt;code&gt;Transport&lt;/code&gt;&apos;s &lt;code&gt;CloseIdleConnections&lt;/code&gt;  if it has one.&lt;/p&gt;&lt;p&gt;&lt;!-- CL 145398 --&gt;  The &lt;a href=&quot;/pkg/net/http/#Transport&quot;&gt;&lt;code&gt;Transport&lt;/code&gt;&lt;/a&gt; no longer rejects HTTP responses which declare  HTTP Trailers but don&apos;t use chunked encoding. Instead, the declared trailers are now just ignored.&lt;/p&gt;&lt;p&gt;&lt;!-- CL 152080 --&gt; &lt;!-- CL 151857 --&gt;  The &lt;a href=&quot;/pkg/net/http/#Transport&quot;&gt;&lt;code&gt;Transport&lt;/code&gt;&lt;/a&gt; no longer handles &lt;code&gt;MAX_CONCURRENT_STREAMS&lt;/code&gt; values  advertised from HTTP/2 servers as strictly as it did during Go 1.10 and Go 1.11. The default behavior is now back  to how it was in Go 1.9: each connection to a server can have up to &lt;code&gt;MAX_CONCURRENT_STREAMS&lt;/code&gt; requests  active and then new TCP connections are created as needed. In Go 1.10 and Go 1.11 the &lt;code&gt;http2&lt;/code&gt; package  would block and wait for requests to finish instead of creating new connections.  To get the stricter behavior back, import the  &lt;a href=&quot;https://godoc.org/golang.org/x/net/http2&quot;&gt;&lt;code&gt;golang.org/x/net/http2&lt;/code&gt;&lt;/a&gt; package  directly and set  &lt;a href=&quot;https://godoc.org/golang.org/x/net/http2#Transport.StrictMaxConcurrentStreams&quot;&gt;&lt;code&gt;Transport.StrictMaxConcurrentStreams&lt;/code&gt;&lt;/a&gt; to  &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;</code></pre></dd></dl><!-- net/http --><dl id="net/url"><dt><a href="/pkg/net/url/">net/url</a></dt>  <dd>    <p><!-- CL 159157, CL 160178 -->      <a href="/pkg/net/url/#Parse"><code>Parse</code></a>,      <a href="/pkg/net/url/#ParseRequestURI"><code>ParseRequestURI</code></a>,      and      <a href="/pkg/net/url/#URL.Parse"><code>URL.Parse</code></a>      now return an      error for URLs containing ASCII control characters, which includes NULL,      tab, and newlines.    </p></dd></dl><!-- net/url --><dl id="net/http/httputil"><dt><a href="/pkg/net/http/httputil/">net/http/httputil</a></dt>  <dd>    <p><!-- CL 146437 -->      The <a href="/pkg/net/http/httputil/#ReverseProxy"><code>ReverseProxy</code></a> now automatically      proxies WebSocket requests.    </p></dd></dl><!-- net/http/httputil --><dl id="os"><dt><a href="/pkg/os/">os</a></dt>  <dd>    <p><!-- CL 125443 -->      The new <a href="/pkg/os/#ProcessState.ExitCode"><code>ProcessState.ExitCode</code></a> method      returns the process's exit code.    </p><pre><code>&lt;p&gt;&lt;!-- CL 135075 --&gt;  &lt;code&gt;ModeCharDevice&lt;/code&gt; has been added to the &lt;code&gt;ModeType&lt;/code&gt; bitmask, allowing for  &lt;code&gt;ModeDevice | ModeCharDevice&lt;/code&gt; to be recovered when masking a  &lt;a href=&quot;/pkg/os/#FileMode&quot;&gt;&lt;code&gt;FileMode&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;ModeType&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;&lt;!-- CL 139418 --&gt;  The new function &lt;a href=&quot;/pkg/os/#UserHomeDir&quot;&gt;&lt;code&gt;UserHomeDir&lt;/code&gt;&lt;/a&gt; returns the  current user&apos;s home directory.&lt;/p&gt;&lt;p&gt;&lt;!-- CL 146020 --&gt;  &lt;a href=&quot;/pkg/os/#RemoveAll&quot;&gt;&lt;code&gt;RemoveAll&lt;/code&gt;&lt;/a&gt; now supports paths longer than 4096 characters  on most Unix systems.&lt;/p&gt;&lt;p&gt;&lt;!-- CL 130676 --&gt;  &lt;a href=&quot;/pkg/os/#File.Sync&quot;&gt;&lt;code&gt;File.Sync&lt;/code&gt;&lt;/a&gt; now uses &lt;code&gt;F_FULLFSYNC&lt;/code&gt; on macOS  to correctly flush the file contents to permanent storage.  This may cause the method to run more slowly than in previous releases.&lt;/p&gt;&lt;p&gt;&lt;!--CL 155517 --&gt;  &lt;a href=&quot;/pkg/os/#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; now supports  a &lt;a href=&quot;/pkg/os/#File.SyscallConn&quot;&gt;&lt;code&gt;SyscallConn&lt;/code&gt;&lt;/a&gt;  method returning  a &lt;a href=&quot;/pkg/syscall/#RawConn&quot;&gt;&lt;code&gt;syscall.RawConn&lt;/code&gt;&lt;/a&gt;  interface value. This may be used to invoke system-specific  operations on the underlying file descriptor.&lt;/p&gt;</code></pre></dd></dl><!-- os --><dl id="path/filepath"><dt><a href="/pkg/path/filepath/">path/filepath</a></dt>  <dd>    <p><!-- CL 145220 -->      The <a href="/pkg/path/filepath/#IsAbs"><code>IsAbs</code></a> function now returns true when passed      a reserved filename on Windows such as <code>NUL</code>.      <a href="https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#naming-conventions" target="_blank" rel="noopener">List of reserved names.</a>    </p></dd></dl><!-- path/filepath --><dl id="reflect"><dt><a href="/pkg/reflect/">reflect</a></dt>  <dd>    <p><!-- CL 33572 -->      A new <a href="/pkg/reflect#MapIter"><code>MapIter</code></a> type is      an iterator for ranging over a map. This type is exposed through the      <a href="/pkg/reflect#Value"><code>Value</code></a> type's new      <a href="/pkg/reflect#Value.MapRange"><code>MapRange</code></a> method.      This follows the same iteration semantics as a range statement, with <code>Next</code>      to advance the iterator, and <code>Key</code>/<code>Value</code> to access each entry.    </p></dd></dl><!-- reflect --><dl id="regexp"><dt><a href="/pkg/regexp/">regexp</a></dt>  <dd>    <p><!-- CL 139784 -->      <a href="/pkg/regexp/#Regexp.Copy"><code>Copy</code></a> is no longer necessary      to avoid lock contention, so it has been given a partial deprecation comment.      <a href="/pkg/regexp/#Regexp.Copy"><code>Copy</code></a>      may still be appropriate if the reason for its use is to make two copies with      different <a href="/pkg/regexp/#Regexp.Longest"><code>Longest</code></a> settings.    </p></dd></dl><!-- regexp --><dl id="runtime/debug"><dt><a href="/pkg/runtime/debug/">runtime/debug</a></dt>  <dd>    <p><!-- CL 144220 -->      A new <a href="/pkg/runtime/debug/#BuildInfo"><code>BuildInfo</code></a> type      exposes the build information read from the running binary, available only in      binaries built with module support. This includes the main package path, main      module information, and the module dependencies. This type is given through the      <a href="/pkg/runtime/debug/#ReadBuildInfo"><code>ReadBuildInfo</code></a> function      on <a href="/pkg/runtime/debug/#BuildInfo"><code>BuildInfo</code></a>.    </p></dd></dl><!-- runtime/debug --><dl id="strings"><dt><a href="/pkg/strings/">strings</a></dt>  <dd>    <p><!-- CL 137855 -->      The new function <a href="/pkg/strings/#ReplaceAll"><code>ReplaceAll</code></a> returns a copy of      a string with all non-overlapping instances of a value replaced by another.    </p><pre><code>&lt;p&gt;&lt;!-- CL 145098 --&gt;  A pointer to a zero-value &lt;a href=&quot;/pkg/strings/#Reader&quot;&gt;&lt;code&gt;Reader&lt;/code&gt;&lt;/a&gt; is now  functionally equivalent to &lt;a href=&quot;/pkg/strings/#NewReader&quot;&gt;&lt;code&gt;NewReader&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(nil)&lt;/code&gt;.  Prior to Go 1.12, the former could not be used as a substitute for the latter in all cases.&lt;/p&gt;&lt;p&gt;&lt;!-- CL 122835 --&gt;  The new &lt;a href=&quot;/pkg/strings/#Builder.Cap&quot;&gt;&lt;code&gt;Builder.Cap&lt;/code&gt;&lt;/a&gt; method returns the capacity of the builder&apos;s underlying byte slice.&lt;/p&gt;&lt;p&gt;&lt;!-- CL 131495 --&gt;  The character mapping functions &lt;a href=&quot;/pkg/strings/#Map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;,  &lt;a href=&quot;/pkg/strings/#Title&quot;&gt;&lt;code&gt;Title&lt;/code&gt;&lt;/a&gt;,  &lt;a href=&quot;/pkg/strings/#ToLower&quot;&gt;&lt;code&gt;ToLower&lt;/code&gt;&lt;/a&gt;,  &lt;a href=&quot;/pkg/strings/#ToLowerSpecial&quot;&gt;&lt;code&gt;ToLowerSpecial&lt;/code&gt;&lt;/a&gt;,  &lt;a href=&quot;/pkg/strings/#ToTitle&quot;&gt;&lt;code&gt;ToTitle&lt;/code&gt;&lt;/a&gt;,  &lt;a href=&quot;/pkg/strings/#ToTitleSpecial&quot;&gt;&lt;code&gt;ToTitleSpecial&lt;/code&gt;&lt;/a&gt;,  &lt;a href=&quot;/pkg/strings/#ToUpper&quot;&gt;&lt;code&gt;ToUpper&lt;/code&gt;&lt;/a&gt;, and  &lt;a href=&quot;/pkg/strings/#ToUpperSpecial&quot;&gt;&lt;code&gt;ToUpperSpecial&lt;/code&gt;&lt;/a&gt;  now always guarantee to return valid UTF-8. In earlier releases, if the input was invalid UTF-8 but no character replacements  needed to be applied, these routines incorrectly returned the invalid UTF-8 unmodified.&lt;/p&gt;</code></pre></dd></dl><!-- strings --><dl id="syscall"><dt><a href="/pkg/syscall/">syscall</a></dt>  <dd>    <p><!-- CL 138595 -->      64-bit inodes are now supported on FreeBSD 12. Some types have been adjusted accordingly.    </p><pre><code>&lt;p&gt;&lt;!-- CL 125456 --&gt;  The Unix socket  (&lt;a href=&quot;https://blogs.msdn.microsoft.com/commandline/2017/12/19/af_unix-comes-to-windows/&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt;)  address family is now supported for compatible versions of Windows.&lt;/p&gt;&lt;p&gt;&lt;!-- CL 147117 --&gt;  The new function  &lt;a href=&quot;/pkg/syscall/?GOOS=windows&amp;GOARCH=amd64#Syscall18&quot;&gt;&lt;code&gt;Syscall18&lt;/code&gt;&lt;/a&gt;  has been introduced for Windows, allowing for calls with up to 18 arguments.&lt;/p&gt;</code></pre></dd></dl><!-- syscall --><dl id="syscall/js"><dt><a href="/pkg/syscall/js/">syscall/js</a></dt>  <dd>    <p><!-- CL 153559 -->    </p><p>      The <code>Callback</code> type and <code>NewCallback</code> function have been renamed;      they are now called      <a href="/pkg/syscall/js/?GOOS=js&GOARCH=wasm#Func"><code>Func</code></a> and      <a href="/pkg/syscall/js/?GOOS=js&GOARCH=wasm#FuncOf"><code>FuncOf</code></a>, respectively.      This is a breaking change, but WebAssembly support is still experimental      and not yet subject to the      <a href="/doc/go1compat">Go 1 compatibility promise</a>. Any code using the      old names will need to be updated.    </p><pre><code>&lt;p&gt;&lt;!-- CL 141644 --&gt;  If a type implements the new  &lt;a href=&quot;/pkg/syscall/js/?GOOS=js&amp;GOARCH=wasm#Wrapper&quot;&gt;&lt;code&gt;Wrapper&lt;/code&gt;&lt;/a&gt;  interface,  &lt;a href=&quot;/pkg/syscall/js/?GOOS=js&amp;GOARCH=wasm#ValueOf&quot;&gt;&lt;code&gt;ValueOf&lt;/code&gt;&lt;/a&gt;  will use it to return the JavaScript value for that type.&lt;/p&gt;&lt;p&gt;&lt;!-- CL 143137 --&gt;  The meaning of the zero  &lt;a href=&quot;/pkg/syscall/js/?GOOS=js&amp;GOARCH=wasm#Value&quot;&gt;&lt;code&gt;Value&lt;/code&gt;&lt;/a&gt;  has changed. It now represents the JavaScript &lt;code&gt;undefined&lt;/code&gt; value  instead of the number zero.  This is a breaking change, but WebAssembly support is still experimental  and not yet subject to the  &lt;a href=&quot;/doc/go1compat&quot;&gt;Go 1 compatibility promise&lt;/a&gt;. Any code relying on  the zero &lt;a href=&quot;/pkg/syscall/js/?GOOS=js&amp;GOARCH=wasm#Value&quot;&gt;&lt;code&gt;Value&lt;/code&gt;&lt;/a&gt;  to mean the number zero will need to be updated.&lt;/p&gt;&lt;p&gt;&lt;!-- CL 144384 --&gt;  The new  &lt;a href=&quot;/pkg/syscall/js/?GOOS=js&amp;GOARCH=wasm#Value.Truthy&quot;&gt;&lt;code&gt;Value.Truthy&lt;/code&gt;&lt;/a&gt;  method reports the  &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;JavaScript &quot;truthiness&quot;&lt;/a&gt;  of a given value.&lt;/p&gt;</code></pre></dd></dl><!-- syscall/js --><dl id="testing"><dt><a href="/pkg/testing/">testing</a></dt>  <dd>    <p><!-- CL 139258 -->    The <a href="/cmd/go/#hdr-Testing_flags"><code>-benchtime</code></a> flag now supports setting an explicit iteration count instead of a time when the value ends with an "<code>x</code>". For example, <code>-benchtime=100x</code> runs the benchmark 100 times.    </p></dd></dl><!-- testing --><dl id="text/template"><dt><a href="/pkg/text/template/">text/template</a></dt>  <dd>    <p><!-- CL 142217 -->      When executing a template, long context values are no longer truncated in errors.    </p>    <p>      <code>executing "tmpl" at <.very.deep.context.v...>: map has no entry for key "notpresent"</.very.deep.context.v...></code>    </p>    <p>      is now    </p>    <p>      <code>executing "tmpl" at <.very.deep.context.value.notpresent>: map has no entry for key "notpresent"</.very.deep.context.value.notpresent></code>    </p>  <dd>    <p><!-- CL 143097 -->      If a user-defined function called by a template panics, the      panic is now caught and returned as an error by      the <code>Execute</code> or <code>ExecuteTemplate</code> method.    </p></dd></dd></dl><!-- text/template --><dl id="time"><dt><a href="/pkg/time/">time</a></dt>  <dd>    <p><!-- CL 151299 -->      The time zone database in <code>$GOROOT/lib/time/zoneinfo.zip</code>      has been updated to version 2018i. Note that this ZIP file is      only used if a time zone database is not provided by the operating      system.    </p></dd></dl><!-- time --><dl id="unsafe"><dt><a href="/pkg/unsafe/">unsafe</a></dt>  <dd>    <p><!-- CL 146058 -->      It is invalid to convert a nil <code>unsafe.Pointer</code> to <code>uintptr</code> and back with arithmetic.      (This was already invalid, but will now cause the compiler to misbehave.)    </p></dd></dl><!-- unsafe -->]]></content>
      
      
      <categories>
          
          <category> Go版本 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go代码Review建议</title>
      <link href="/code_review_comments/"/>
      <url>/code_review_comments/</url>
      
        <content type="html"><![CDATA[<p>本页不是一个全面的的风格指南, 只是一个常见问题的清单。这些问题是在review Go代码时会经常遇到的, 所以有些解释比较简略。你可以把它看作是<a href="https://go-lang.fun/effective_go/">《Effective Go》</a>的补充。</p><h2 id="Gofmt"><a href="#Gofmt" class="headerlink" title="Gofmt"></a>Gofmt</h2><p><a href="https://golang.org/cmd/gofmt/" target="_blank" rel="noopener">gofmt</a>在Go代码中被广泛使用, 对代码运行gofmt可以自动修复绝大多数的基础代码格式问题。</p><p>还有一种选择是使用<a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">goimports</a>，它是gofmt的一个超集，可以根据需要自动添加（和删除）import行。</p><h2 id="注释语句"><a href="#注释语句" class="headerlink" title="注释语句"></a>注释语句</h2><p>建议先看看<a href="https://go-lang.fun/effective_go/#commentary">《Effective Go》中对注释的建议</a>。 注释语句应当书写一个完整的句子, 尽管这看上去有些啰嗦, 却使它们在提取到GoDoc文档中的时候格式良好。注释应当以所描述对象的名称开始，并以句号结束:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request represents a request to run a command.</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123; ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encode writes the JSON encoding of req to w.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(w io.Writer, req *Request)</span></span> &#123; ...</span><br></pre></td></tr></table></figure><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Values of the context.Context type carry security credentials,<br>tracing information, deadlines, and cancellation signals across API<br>and process boundaries. Go programs pass Contexts explicitly along<br>the entire function call chain from incoming RPCs and HTTP requests<br>to outgoing requests.</p><p>Most functions that use a Context should accept it as their first parameter:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">(ctx context.Context, /* other arguments */)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>A function that is never request-specific may use context.Background(),<br>but err on the side of passing a Context even if you think you don’t need<br>to. The default case is to pass a Context; only use context.Background()<br>directly if you have a good reason why the alternative is a mistake.</p><p>Don’t add a Context member to a struct type; instead add a ctx parameter<br>to each method on that type that needs to pass it along. The one exception<br>is for methods whose signature must match an interface in the standard library<br>or in a third party library.</p><p>Don’t create custom Context types or use interfaces other than Context in<br>function signatures.</p><p>If you have application data to pass around, put it in a parameter,<br>in the receiver, in globals, or, if it truly belongs there, in a Context value.</p><p>Contexts are immutable, so it’s fine to pass the same ctx to multiple<br>calls that share the same deadline, cancellation signal, credentials,<br>parent trace, etc.</p><h2 id="Copying"><a href="#Copying" class="headerlink" title="Copying"></a>Copying</h2><p>To avoid unexpected aliasing, be careful when copying a struct from another package.<br>For example, the bytes.Buffer type contains a <code>[]byte</code> slice and, as an optimization<br>for small strings, a small byte array to which the slice may refer. If you copy a <code>Buffer</code>,the slice in the copy may alias the array in the original, causing subsequent method<br>calls to have surprising effects.</p><p>In general, do not copy a value of type <code>T</code> if its methods are associated with the<br>pointer type, <code>*T</code>.</p><h2 id="Declaring-Empty-Slices"><a href="#Declaring-Empty-Slices" class="headerlink" title="Declaring Empty Slices"></a>Declaring Empty Slices</h2><p>When declaring an empty slice, prefer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t []<span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>over </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := []<span class="keyword">string</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>The former declares a nil slice value, while the latter is non-nil but zero-length. They are functionally equivalent—their <code>len</code> and <code>cap</code> are both zero—but the nil slice is the preferred style.</p><p>Note that there are limited circumstances where a non-nil but zero-length slice is preferred, such as when encoding JSON objects (a <code>nil</code> slice encodes to <code>null</code>, while <code>[]string{}</code> encodes to the JSON array <code>[]</code>).</p><p>When designing interfaces, avoid making a distinction between a nil slice and a non-nil, zero-length slice, as this can lead to subtle programming errors.</p><p>For more discussion about nil in Go see Francesc Campoy’s talk <a href="https://www.youtube.com/watch?v=ynoY2xz-F8s" target="_blank" rel="noopener">Understanding Nil</a>.</p><h2 id="Crypto-Rand"><a href="#Crypto-Rand" class="headerlink" title="Crypto Rand"></a>Crypto Rand</h2><p>Do not use package <code>math/rand</code> to generate keys, even throwaway ones.<br>Unseeded, the generator is completely predictable. Seeded with <code>time.Nanoseconds()</code>,there are just a few bits of entropy. Instead, use <code>crypto/rand</code>‘s Reader,<br>and if you need text, print to hexadecimal or base64:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="comment">// "encoding/base64"</span></span><br><span class="line">    <span class="comment">// "encoding/hex"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Key</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">16</span>)</span><br><span class="line">    _, err := rand.Read(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)  <span class="comment">// out of randomness, should never happen</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%x"</span>, buf)</span><br><span class="line">    <span class="comment">// or hex.EncodeToString(buf)</span></span><br><span class="line">    <span class="comment">// or base64.StdEncoding.EncodeToString(buf)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Doc-Comments"><a href="#Doc-Comments" class="headerlink" title="Doc Comments"></a>Doc Comments</h2><p>All top-level, exported names should have doc comments, as should non-trivial unexported type or function declarations. See <a href="https://go-lang.fun/effective_go/#commentary">https://go-lang.fun/effective_go/#commentary</a> for more information about commentary conventions.</p><h2 id="不要滥用Panic"><a href="#不要滥用Panic" class="headerlink" title="不要滥用Panic"></a>不要滥用Panic</h2><p>See <a href="https://go-lang.fun/effective_go/#errors">https://go-lang.fun/effective_go/#errors</a>. Don’t use panic for normal error handling. Use error and multiple return values.</p><h2 id="Error-Strings"><a href="#Error-Strings" class="headerlink" title="Error Strings"></a>Error Strings</h2><p>Error strings should not be capitalized (unless beginning with proper nouns or acronyms) or end with punctuation, since they are usually printed following other context. That is, use <code>fmt.Errorf(&quot;something bad&quot;)</code> not <code>fmt.Errorf(&quot;Something bad&quot;)</code>, so that <code>log.Printf(&quot;Reading %s: %v&quot;, filename, err)</code> formats without a spurious capital letter mid-message. This does not apply to logging, which is implicitly line-oriented and not combined inside other messages.</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>When adding a new package, include examples of intended usage: a runnable Example,<br>or a simple test demonstrating a complete call sequence.</p><p>Read more about <a href="https://blog.golang.org/examples" target="_blank" rel="noopener">testable Example() functions</a>.</p><h2 id="Goroutine生命周期"><a href="#Goroutine生命周期" class="headerlink" title="Goroutine生命周期"></a>Goroutine生命周期</h2><p>When you spawn goroutines, make it clear when - or whether - they exit.</p><p>Goroutines can leak by blocking on channel sends or receives: the garbage collector<br>will not terminate a goroutine even if the channels it is blocked on are unreachable.</p><p>Even when goroutines do not leak, leaving them in-flight when they are no longer<br>needed can cause other subtle and hard-to-diagnose problems. Sends on closed channels<br>panic. Modifying still-in-use inputs “after the result isn’t needed” can still lead<br>to data races. And leaving goroutines in-flight for arbitrarily long can lead to<br>unpredictable memory usage.</p><p>Try to keep concurrent code simple enough that goroutine lifetimes are obvious.<br>If that just isn’t feasible, document when and why the goroutines exit.</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>See <a href="https://go-lang.fun/effective_go/#errors">https://go-lang.fun/effective_go/#errors</a>. Do not discard errors using <code>_</code> variables. If a function returns an error, check it to make sure the function succeeded. Handle the error, return it, or, in truly exceptional situations, panic.</p><h2 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h2><p>Avoid renaming imports except to avoid a name collision; good package names<br>should not require renaming. In the event of collision, prefer to rename the most<br>local or project-specific import.</p><p>Imports are organized in groups, with blank lines between them.<br>The standard library packages are always in the first group.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"hash/adler32"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"appengine/foo"</span></span><br><span class="line"><span class="string">"appengine/user"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"github.com/foo/bar"</span></span><br><span class="line"><span class="string">"rsc.io/goversion/version"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">goimports</a> will do this for you.</p><h2 id="ImportBlank"><a href="#ImportBlank" class="headerlink" title="ImportBlank"></a>ImportBlank</h2><p>Packages that are imported only for their side effects (using the syntax <code>import_ &quot;pkg&quot;</code>) should only be imported in the main package of a program, or in tests<br>that require them.</p><h2 id="Import-Dot"><a href="#Import-Dot" class="headerlink" title="Import Dot"></a>Import Dot</h2><p>The import . form can be useful in tests that, due to circular dependencies, cannot be made part of the package being tested:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bar/testutil"</span> <span class="comment">// also imports "foo"</span></span><br><span class="line">. <span class="string">"foo"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>In this case, the test file cannot be in package foo because it uses bar/testutil, which imports foo.  So we use the ‘import .’ form to let the file pretend to be part of package foo even though it is not.  Except for this one case, do not use import . in your programs.  It makes the programs much harder to read because it is unclear whether a name like Quux is a top-level identifier in the current package or in an imported package.</p><h2 id="In-Band-Errors"><a href="#In-Band-Errors" class="headerlink" title="In-Band Errors"></a>In-Band Errors</h2><p>In C and similar languages, it’s common for functions to return values like -1<br>or null to signal errors or missing results:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lookup returns the value for key or "" if there is no mapping for key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Failing</span> <span class="title">to</span> <span class="title">check</span> <span class="title">a</span> <span class="title">for</span> <span class="title">an</span> <span class="title">in</span>-<span class="title">band</span> <span class="title">error</span> <span class="title">value</span> <span class="title">can</span> <span class="title">lead</span> <span class="title">to</span> <span class="title">bugs</span>:</span></span><br><span class="line"><span class="function"><span class="title">Parse</span><span class="params">(Lookup(key)</span>)  // <span class="title">returns</span> "<span class="title">parse</span> <span class="title">failure</span> <span class="title">for</span> <span class="title">value</span>" <span class="title">instead</span> <span class="title">of</span> "<span class="title">no</span> <span class="title">value</span> <span class="title">for</span> <span class="title">key</span>"</span></span><br></pre></td></tr></table></figure><p>Go’s support for multiple return values provides a better solution.<br>Instead of requiring clients to check for an in-band error value, a function should return<br>an additional value to indicate whether its other return values are valid. This return<br>value may be an error, or a boolean when no explanation is needed.<br>It should be the final return value.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lookup returns the value for key or ok=false if there is no mapping for key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">string</span>, ok <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure><p>This prevents the caller from using the result incorrectly:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parse(Lookup(key))  <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure><p>And encourages more robust and readable code:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value, ok := Lookup(key)</span><br><span class="line"><span class="keyword">if</span> !ok  &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"no value for %q"</span>, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Parse(value)</span><br></pre></td></tr></table></figure><p>This rule applies to exported functions but is also useful<br>for unexported functions.</p><p>Return values like nil, “”, 0, and -1 are fine when they are<br>valid results for a function, that is, when the caller need not<br>handle them differently from other values.</p><p>Some standard library functions, like those in package “strings”,<br>return in-band error values. This greatly simplifies string-manipulation<br>code at the cost of requiring more diligence from the programmer.<br>In general, Go code should return additional values for errors.</p><h2 id="Indent-Error-Flow"><a href="#Indent-Error-Flow" class="headerlink" title="Indent Error Flow"></a>Indent Error Flow</h2><p>Try to keep the normal code path at a minimal indentation, and indent the error handling, dealing with it first. This improves the readability of the code by permitting visually scanning the normal path quickly. For instance, don’t write:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// error handling</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// normal code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Instead, write:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// error handling</span></span><br><span class="line"><span class="keyword">return</span> <span class="comment">// or continue, etc.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// normal code</span></span><br></pre></td></tr></table></figure><p>If the <code>if</code> statement has an initialization statement, such as:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x, err := f(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// error handling</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// use x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>then this may require moving the short variable declaration to its own line:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x, err := f()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// error handling</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use x</span></span><br></pre></td></tr></table></figure><h2 id="Initialisms"><a href="#Initialisms" class="headerlink" title="Initialisms"></a>Initialisms</h2><p>Words in names that are initialisms or acronyms (e.g. “URL” or “NATO”) have a consistent case. For example, “URL” should appear as “URL” or “url” (as in “urlPony”, or “URLPony”), never as “Url”. As an example: ServeHTTP not ServeHttp. For identifiers with multiple initialized “words”, use for example “xmlHTTPRequest” or “XMLHTTPRequest”.</p><p>This rule also applies to “ID” when it is short for “identifier” (which is pretty much all cases when it’s not the “id” as in “ego”, “superego”), so write “appID” instead of “appId”.</p><p>Code generated by the protocol buffer compiler is exempt from this rule. Human-written code is held to a higher standard than machine-written code.</p><h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><p>Go interfaces generally belong in the package that uses values of the<br>interface type, not the package that implements those values. The<br>implementing package should return concrete (usually pointer or struct)<br>types: that way, new methods can be added to implementations without<br>requiring extensive refactoring.</p><p>Do not define interfaces on the implementor side of an API “for mocking”;<br>instead, design the API so that it can be tested using the public API of<br>the real implementation.</p><p>Do not define interfaces before they are used: without a realistic example<br>of usage, it is too difficult to see whether an interface is even necessary,<br>let alone what methods it ought to contain.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> consumer  <span class="comment">// consumer.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Thinger <span class="keyword">interface</span> &#123; Thing() <span class="keyword">bool</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(t Thinger)</span> <span class="title">string</span></span> &#123; … &#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> consumer <span class="comment">// consumer_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeThinger <span class="keyword">struct</span>&#123; … &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t fakeThinger)</span> <span class="title">Thing</span><span class="params">()</span> <span class="title">bool</span></span> &#123; … &#125;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">if</span> Foo(fakeThinger&#123;…&#125;) == <span class="string">"x"</span> &#123; … &#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DO NOT DO IT!!!</span></span><br><span class="line"><span class="keyword">package</span> producer</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Thinger <span class="keyword">interface</span> &#123; Thing() <span class="keyword">bool</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> defaultThinger <span class="keyword">struct</span>&#123; … &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t defaultThinger)</span> <span class="title">Thing</span><span class="params">()</span> <span class="title">bool</span></span> &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewThinger</span><span class="params">()</span> <span class="title">Thinger</span></span> &#123; <span class="keyword">return</span> defaultThinger&#123; … &#125; &#125;</span><br></pre></td></tr></table></figure><p>Instead return a concrete type and let the consumer mock the producer implementation.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> producer</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Thinger <span class="keyword">struct</span>&#123; … &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Thinger)</span> <span class="title">Thing</span><span class="params">()</span> <span class="title">bool</span></span> &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewThinger</span><span class="params">()</span> <span class="title">Thinger</span></span> &#123; <span class="keyword">return</span> Thinger&#123; … &#125; &#125;</span><br></pre></td></tr></table></figure><h2 id="一行代码的长度"><a href="#一行代码的长度" class="headerlink" title="一行代码的长度"></a>一行代码的长度</h2><p>There is no rigid line length limit in Go code, but avoid uncomfortably long lines.<br>Similarly, don’t add line breaks to keep lines short when they are more readable long–for example,<br>if they are repetitive.</p><p>Most of the time when people wrap lines “unnaturally” (in the middle of function calls or<br>function declarations, more or less, say, though some exceptions are around), the wrapping would be<br>unnecessary if they had a reasonable number of parameters and reasonably short variable names.<br>Long lines seem to go with long names, and getting rid of the long names helps a lot.</p><p>In other words, break lines because of the semantics of what you’re writing (as a general rule)<br>and not because of the length of the line. If you find that this produces lines that are too long,<br>then change the names or the semantics and you’ll probably get a good result.</p><p>This is, actually, exactly the same advice about how long a function should be. There’s no rule<br>“never have a function more than N lines long”, but there is definitely such a thing as too long<br>of a function, and of too stuttery tiny functions, and the solution is to change where the function<br>boundaries are, not to start counting lines.</p><h2 id="Mixed-Caps"><a href="#Mixed-Caps" class="headerlink" title="Mixed Caps"></a>Mixed Caps</h2><p>See <a href="https://go-lang.fun/effective_go/#mixed-caps">https://go-lang.fun/effective_go/#mixed-caps</a>. This applies even when it breaks conventions in other languages. For example an unexported constant is <code>maxLength</code> not <code>MaxLength</code> or <code>MAX_LENGTH</code>.</p><p>Also see <a href="https://github.com/golang/go/wiki/CodeReviewComments#initialisms" target="_blank" rel="noopener">Initialisms</a>.</p><h2 id="Named-Result-Parameters"><a href="#Named-Result-Parameters" class="headerlink" title="Named Result Parameters"></a>Named Result Parameters</h2><p>Consider what it will look like in godoc.  Named result parameters like:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">Parent1</span><span class="params">()</span> <span class="params">(node *Node)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(n *Node)</span> <span class="title">Parent2</span><span class="params">()</span> <span class="params">(node *Node, err error)</span></span></span><br></pre></td></tr></table></figure><p>will stutter in godoc; better to use:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">Parent1</span><span class="params">()</span> *<span class="title">Node</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(n *Node)</span> <span class="title">Parent2</span><span class="params">()</span> <span class="params">(*Node, error)</span></span></span><br></pre></td></tr></table></figure><p>On the other hand, if a function returns two or three parameters of the same type,<br>or if the meaning of a result isn’t clear from context, adding names may be useful<br>in some contexts. Don’t name result parameters just to avoid declaring a var inside<br>the function; that trades off a minor implementation brevity at the cost of<br>unnecessary API verbosity.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Foo)</span> <span class="title">Location</span><span class="params">()</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">float64</span>, error)</span></span></span><br></pre></td></tr></table></figure><p>is less clear than:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Location returns f's latitude and longitude.</span></span><br><span class="line"><span class="comment">// Negative values mean south and west, respectively.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Foo)</span> <span class="title">Location</span><span class="params">()</span> <span class="params">(lat, long <span class="keyword">float64</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>Naked returns are okay if the function is a handful of lines. Once it’s a medium<br>sized function, be explicit with your return values. Corollary: it’s not worth it<br>to name result parameters just because it enables you to use naked returns.<br>Clarity of docs is always more important than saving a line or two in your function.</p><p>Finally, in some cases you need to name a result parameter in order to change<br>it in a deferred closure. That is always OK.</p><h2 id="Naked-Returns"><a href="#Naked-Returns" class="headerlink" title="Naked Returns"></a>Naked Returns</h2><p>See <a href="#named-result-parameters">Named Result Parameters</a>.</p><h2 id="Package-Comments"><a href="#Package-Comments" class="headerlink" title="Package Comments"></a>Package Comments</h2><p>Package comments, like all comments to be presented by godoc, must appear adjacent to the package clause, with no blank line.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package math provides basic constants and mathematical functions.</span></span><br><span class="line"><span class="keyword">package</span> math</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Package template implements data-driven templates for generating textual</span></span><br><span class="line"><span class="comment">output such as HTML.</span></span><br><span class="line"><span class="comment">....</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> template</span><br></pre></td></tr></table></figure><p>For “package main” comments, other styles of comment are fine after the binary name (and it may be capitalized if it comes first), For example, for a <code>package main</code> in the directory <code>seedgen</code> you could write:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Binary seedgen ...</span></span><br><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Command seedgen ...</span></span><br><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Program seedgen ...</span></span><br><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The seedgen command ...</span></span><br><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The seedgen program ...</span></span><br><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Seedgen ..</span></span><br><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure><p>These are examples, and sensible variants of these are acceptable.</p><p>Note that starting the sentence with a lower-case word is not among the<br>acceptable options for package comments, as these are publicly-visible and<br>should be written in proper English, including capitalizing the first word<br>of the sentence. When the binary name is the first word, capitalizing it is<br>required even though it does not strictly match the spelling of the<br>command-line invocation.</p><p>See <a href="https://go-lang.fun/effective_go/#commentary">https://go-lang.fun/effective_go/#commentary</a> for more information about commentary conventions.</p><h2 id="Package-Names"><a href="#Package-Names" class="headerlink" title="Package Names"></a>Package Names</h2><p>All references to names in your package will be done using the package name,<br>so you can omit that name from the identifiers. For example, if you are in package chubby,<br>you don’t need type ChubbyFile, which clients will write as <code>chubby.ChubbyFile</code>.Instead, name the type <code>File</code>, which clients will write as <code>chubby.File</code>.Avoid meaningless package names like util, common, misc, api, types, and interfaces. See <a href="http://golang.org/doc/effective_go.html#package-names" target="_blank" rel="noopener">http://golang.org/doc/effective_go.html#package-names</a> and<br><a href="http://blog.golang.org/package-names" target="_blank" rel="noopener">http://blog.golang.org/package-names</a> for more.</p><h2 id="Pass-Values"><a href="#Pass-Values" class="headerlink" title="Pass Values"></a>Pass Values</h2><p>Don’t pass pointers as function arguments just to save a few bytes.  If a function refers to its argument <code>x</code> only as <code>*x</code> throughout, then the argument shouldn’t be a pointer.  Common instances of this include passing a pointer to a string (<code>*string</code>) or a pointer to an interface value (<code>*io.Reader</code>).  In both cases the value itself is a fixed size and can be passed directly.  This advice does not apply to large structs, or even small structs that might grow.</p><h2 id="Receiver-Names"><a href="#Receiver-Names" class="headerlink" title="Receiver Names"></a>Receiver Names</h2><p>The name of a method’s receiver should be a reflection of its identity; often a one or two letter abbreviation of its type suffices (such as “c” or “cl” for “Client”). Don’t use generic names such as “me”, “this” or “self”, identifiers typical of object-oriented languages that gives the method a special meaning. In Go, the receiver of a method is just another parameter and therefore, should be named accordingly. The name need not be as descriptive as that of a method argument, as its role is obvious and serves no documentary purpose. It can be very short as it will appear on almost every line of every method of the type; familiarity admits brevity. Be consistent, too: if you call the receiver “c” in one method, don’t call it “cl” in another.</p><h2 id="Receiver-Type"><a href="#Receiver-Type" class="headerlink" title="Receiver Type"></a>Receiver Type</h2><p>Choosing whether to use a value or pointer receiver on methods can be difficult, especially to new Go programmers.  If in doubt, use a pointer, but there are times when a value receiver makes sense, usually for reasons of efficiency, such as for small unchanging structs or values of basic type. Some useful guidelines:</p><ul><li>If the receiver is a map, func or chan, don’t use a pointer to them. If the receiver is a slice and the method doesn’t reslice or reallocate the slice, don’t use a pointer to it.</li><li>If the method needs to mutate the receiver, the receiver must be a pointer.</li><li>If the receiver is a struct that contains a sync.Mutex or similar synchronizing field, the receiver must be a pointer to avoid copying.</li><li>If the receiver is a large struct or array, a pointer receiver is more efficient.  How large is large?  Assume it’s equivalent to passing all its elements as arguments to the method.  If that feels too large, it’s also too large for the receiver.</li><li>Can function or methods, either concurrently or when called from this method, be mutating the receiver? A value type creates a copy of the receiver when the method is invoked, so outside updates will not be applied to this receiver. If changes must be visible in the original receiver, the receiver must be a pointer.</li><li>If the receiver is a struct, array or slice and any of its elements is a pointer to something that might be mutating, prefer a pointer receiver, as it will make the intention more clear to the reader.</li><li>If the receiver is a small array or struct that is naturally a value type (for instance, something like the time.Time type), with no mutable fields and no pointers, or is just a simple basic type such as int or string, a value receiver makes sense.  A value receiver can reduce the amount of garbage that can be generated; if a value is passed to a value method, an on-stack copy can be used instead of allocating on the heap. (The compiler tries to be smart about avoiding this allocation, but it can’t always succeed.) Don’t choose a value receiver type for this reason without profiling first.</li><li>Finally, when in doubt, use a pointer receiver.</li></ul><h2 id="Synchronous-Functions"><a href="#Synchronous-Functions" class="headerlink" title="Synchronous Functions"></a>Synchronous Functions</h2><p>Prefer synchronous functions - functions which return their results directly or finish any callbacks or channel ops before returning - over asynchronous ones.</p><p>Synchronous functions keep goroutines localized within a call, making it easier to reason about their lifetimes and avoid leaks and data races. They’re also easier to test: the caller can pass an input and check the output without the need for polling or synchronization.</p><p>If callers need more concurrency, they can add it easily by calling the function from a separate goroutine. But it is quite difficult - sometimes impossible - to remove unnecessary concurrency at the caller side.</p><h2 id="Useful-Test-Failures"><a href="#Useful-Test-Failures" class="headerlink" title="Useful Test Failures"></a>Useful Test Failures</h2><p>Tests should fail with helpful messages saying what was wrong, with what inputs, what was actually got, and what was expected.  It may be tempting to write a bunch of assertFoo helpers, but be sure your helpers produce useful error messages.  Assume that the person debugging your failing test is not you, and is not your team.  A typical Go test fails like:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> got != tt.want &#123;</span><br><span class="line">t.Errorf(<span class="string">"Foo(%q) = %d; want %d"</span>, tt.in, got, tt.want) <span class="comment">// or Fatalf, if test can't test anything more past this point</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the order here is actual != expected, and the message uses that order too. Some test frameworks encourage writing these backwards: 0 != x, “expected 0, got x”, and so on. Go does not.</p><p>If that seems like a lot of typing, you may want to write a [[table-driven test|TableDrivenTests]].</p><p>Another common technique to disambiguate failing tests when using a test helper with different input is to wrap each caller with a different TestFoo function, so the test fails with that name:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSingleValue</span><span class="params">(t *testing.T)</span></span> &#123; testHelper(t, []<span class="keyword">int</span>&#123;<span class="number">80</span>&#125;) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNoValues</span><span class="params">(t *testing.T)</span></span>    &#123; testHelper(t, []<span class="keyword">int</span>&#123;&#125;) &#125;</span><br></pre></td></tr></table></figure><p>In any case, the onus is on you to fail with a helpful message to whoever’s debugging your code in the future.</p><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>Variable names in Go should be short rather than long.  This is especially true for local variables with limited scope.  Prefer <code>c</code> to <code>lineCount</code>.  Prefer <code>i</code> to <code>sliceIndex</code>.</p><p>The basic rule: the further from its declaration that a name is used, the more descriptive the name must be. For a method receiver, one or two letters is sufficient. Common variables such as loop indices and readers can be a single letter (<code>i</code>, <code>r</code>). More unusual things and global variables need more descriptive names.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go版本发布历史</title>
      <link href="/go_release/"/>
      <url>/go_release/</url>
      
        <content type="html"><![CDATA[<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>Go语言发布版本号遵循Version.Marjor.Minor的格式。比如Go1.12.5，代表了Version1，Marjor12，Minor5。</p><p>Version代表语言规范的版本。如Go1和即将发布的Go2，他们在语法，数据类型等层面都有所区别。</p><p>Marjor代表主要的版本。编程语言的开发也要分时间分阶段的逐步完善，语言特性及标准库等等被分到不同的Marjor中去实现再发布。</p><p>Minor代表次要的版本。只对重要的功能问题及重要的安全问题进行修复。</p><h2 id="发布周期"><a href="#发布周期" class="headerlink" title="发布周期"></a>发布周期</h2><p>以Go1的历史发布来看，基本保持在6个月出一个新Marjor的节奏。</p><h2 id="支持周期"><a href="#支持周期" class="headerlink" title="支持周期"></a>支持周期</h2><p>每个Marjor版本在其后第二个Marjor版本发布前会获得支持。也就是说Go 1.5会在Go 1.7发布之前获得问题修复，Go 1.6在Go 1.8发布之前获得问题修复。举个例子：Go 1.5在15年8月19日发布，随后Go 1.6在16年2月17日发布，期间Go 1.5发布了多个问题修复的Minor版本:Go 1.5.1、Go 1.5.2、Go 1.5.3、Go 1.5.4。但是随着Go 1.7在16年8月发布，Go 1.5就不再获得支持，也就是说不再会有新Minor版本发布了。</p><h2 id="Go1-12-2019-02-25发布"><a href="#Go1-12-2019-02-25发布" class="headerlink" title="Go1.12 (2019/02/25发布)"></a>Go1.12 (2019/02/25发布)</h2><p>版本更新详细说明可查看<a href="https://go-lang.fun/go_1.12/">Go 1.12发布说明</a></p><h3 id="Go1-12-1-2019-03-14发布"><a href="#Go1-12-1-2019-03-14发布" class="headerlink" title="Go1.12.1 (2019/03/14发布)"></a>Go1.12.1 (2019/03/14发布)</h3><p>包含对cgo, compiler, go命令行的修复, 以及对标准库中fmt, net/smtp, os, path/filepath, sync, text/template包的修复。详情可查看<a href="https://github.com/golang/go/issues?q=milestone%3AGo1.12.1" target="_blank" rel="noopener">Go1.12.1 milestone</a>。</p><h3 id="Go1-12-2-2019-04-05发布"><a href="#Go1-12-2-2019-04-05发布" class="headerlink" title="Go1.12.2 (2019/04/05发布)"></a>Go1.12.2 (2019/04/05发布)</h3><p>包含对compiler, go命令行, runtime的修复, 以及对标准库中doc, net, net/http/httputil,os包的修复。详情可查看<a href="https://github.com/golang/go/issues?q=milestone%3AGo1.12.2" target="_blank" rel="noopener">Go1.12.2 milestone</a>。</p><h3 id="Go1-12-3-2019-04-08发布"><a href="#Go1-12-3-2019-04-08发布" class="headerlink" title="Go1.12.3 (2019/04/08发布)"></a>Go1.12.3 (2019/04/08发布)</h3><p>在并未修复问题的情况下意外发布。与go1.12.2相比, 只有版本号不一样。</p><h3 id="Go1-12-4-2019-04-11发布"><a href="#Go1-12-4-2019-04-11发布" class="headerlink" title="Go1.12.4 (2019/04/11发布)"></a>Go1.12.4 (2019/04/11发布)</h3><p>修复了在旧版本GNU/Linux上使用了预构建的二进制版本，导致当使用cgo时链接程序失败的问题。只有遇到该问题的Linux用户需要升级。</p><h3 id="Go1-12-5-2019-05-06发布"><a href="#Go1-12-5-2019-05-06发布" class="headerlink" title="Go1.12.5 (2019/05/06发布)"></a>Go1.12.5 (2019/05/06发布)</h3><p> 包含对compiler, linker, go命令行, runtime的修复, 以及对标准库中os包的修复。详情可查看<a href="https://github.com/golang/go/issues?q=milestone%3AGo1.12.5" target="_blank" rel="noopener">Go1.12.5 milestone</a>。</p><h3 id="Go1-12-6-2019-06-11发布"><a href="#Go1-12-6-2019-06-11发布" class="headerlink" title="Go1.12.6 (2019/06/11发布)"></a>Go1.12.6 (2019/06/11发布)</h3><p>包含对compiler, linker, go命令行, 以及对标准库中crypto/x509,net/http以及os包的修复。详情可查看<a href="https://github.com/golang/go/issues?q=milestone%3AGo1.12.6" target="_blank" rel="noopener">Go1.12.6 milestone</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Go版本 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
